<!doctype html>
<html lang="{{ lang }}">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <title>{{ labels['site_title'] }}</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=Fraunces:wght@600&display=swap');
      :root {
        --bg: #0b1220;
        --panel: #121d30;
        --card: #15243a;
        --line: #243652;
        --text: #eef3fb;
        --muted: #9fb3cc;
        --accent: #f5b94f;
        --accent-2: #40d49a;
        --danger: #ff7676;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Space Grotesk", sans-serif;
        background: radial-gradient(circle at 12% 12%, #2a4064 0%, #0b1220 52%, #0b1220 100%);
        color: var(--text);
        min-height: 100vh;
        padding: 24px;
      }
      .topbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 18px;
      }
      .brand-wrap {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 0;
      }
      .brand-text {
        min-width: 0;
      }
      .site-logo {
        width: 46px;
        height: 46px;
        border-radius: 12px;
        border: 1px solid #2a3d57;
        object-fit: cover;
        background: #0f1b2b;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      }
      .brand {
        font-family: "Fraunces", serif;
        font-size: 26px;
      }
      .subtitle { color: var(--muted); font-size: 14px; margin-top: 4px; }
      .top-actions {
        display: flex;
        align-items: stretch;
        gap: 10px;
      }
      .lang-menu {
        position: relative;
      }
      .lang-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        min-height: 54px;
        padding: 0 18px;
        border-radius: 999px;
        border: 1px solid #2a3d57;
        background: #0f1b2b;
        color: var(--text);
        cursor: pointer;
        font-weight: 600;
        font-size: 15px;
        line-height: 1;
        white-space: nowrap;
      }
      .lang-name {
        max-width: 170px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .lang-dropdown {
        position: absolute;
        right: 0;
        top: calc(100% + 8px);
        min-width: 180px;
        max-height: 260px;
        overflow-y: auto;
        background: #0f1b2b;
        border: 1px solid #2a3d57;
        border-radius: 12px;
        padding: 6px;
        display: none;
        z-index: 20;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      }
      .lang-dropdown.open { display: block; }
      .lang-dropdown a {
        display: block;
        padding: 8px 10px;
        color: var(--text);
        text-decoration: none;
        border-radius: 8px;
        font-size: 14px;
      }
      .lang-dropdown a:hover {
        background: #162640;
      }
      .lang-dropdown a.active {
        background: rgba(64, 212, 154, 0.18);
        border: 1px solid rgba(64, 212, 154, 0.4);
      }
      .topup-menu {
        position: relative;
      }
      .topup-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        min-height: 54px;
        padding: 0 18px;
        border-radius: 999px;
        border: 1px solid #2a3d57;
        background: linear-gradient(135deg, #1a2f4b 0%, #13253b 100%);
        color: var(--text);
        cursor: pointer;
        font-weight: 700;
        font-size: 15px;
        line-height: 1;
        white-space: nowrap;
      }
      .topup-dropdown {
        position: absolute;
        right: 0;
        top: calc(100% + 8px);
        width: 220px;
        border-radius: 14px;
        border: 1px solid #2a3d57;
        background: #0f1b2b;
        padding: 6px;
        display: none;
        z-index: 30;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
        transform-origin: top right;
        animation: menu-in 0.16s ease;
      }
      .topup-dropdown.open {
        display: block;
      }
      .topup-item {
        width: 100%;
        border: 1px solid transparent;
        border-radius: 10px;
        background: transparent;
        color: var(--text);
        padding: 10px 12px;
        font: inherit;
        text-align: left;
        cursor: pointer;
      }
      .topup-item:hover {
        background: #162640;
        border-color: #2a3d57;
      }
      @keyframes menu-in {
        from { opacity: 0; transform: scale(0.96); }
        to { opacity: 1; transform: scale(1); }
      }
      @keyframes overlay-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .user-menu {
        position: relative;
      }
      .user-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        min-height: 54px;
        padding: 0 14px;
        border-radius: 999px;
        border: 1px solid #2a3d57;
        background: #0f1b2b;
        color: var(--text);
        cursor: pointer;
        font-weight: 700;
        font-size: 15px;
        line-height: 1;
      }
      .user-avatar {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: #1b2b45;
        border: 1px solid #2b3f59;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        font-weight: 700;
        color: var(--accent);
        background-size: cover;
        background-position: center;
      }
      .user-name {
        font-size: 15px;
        white-space: nowrap;
        max-width: 180px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .user-caret {
        font-size: 14px;
        color: var(--muted);
      }
      .user-dropdown {
        position: absolute;
        right: 0;
        top: calc(100% + 8px);
        min-width: 250px;
        background: #0f1b2b;
        border: 1px solid #2a3d57;
        border-radius: 12px;
        padding: 6px;
        display: none;
        z-index: 20;
        box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      }
      .user-dropdown.open { display: block; }
      .user-dropdown a {
        display: block;
        padding: 8px 10px;
        color: var(--text);
        text-decoration: none;
        border-radius: 8px;
        font-size: 14px;
      }
      .user-dropdown a:hover {
        background: #162640;
      }
      .user-setting {
        display: flex;
        align-items: flex-start;
        gap: 8px;
        padding: 8px 10px;
        margin-bottom: 4px;
        border-radius: 8px;
        color: var(--text);
        font-size: 13px;
        cursor: pointer;
        user-select: none;
      }
      .user-setting:hover {
        background: #162640;
      }
      .user-setting input {
        margin-top: 2px;
      }
      .user-setting.disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .login-widget {
        border: 1px dashed #2a3d57;
        background: #0f1b2b;
        border-radius: 12px;
        padding: 6px 10px;
      }
      .miniapp-auth-note {
        display: none;
        max-width: 320px;
        border: 1px solid #2a3d57;
        background: #0f1b2b;
        border-radius: 12px;
        padding: 10px 12px;
        color: var(--muted);
        font-size: 13px;
      }
      .miniapp-auth-note.error {
        border-color: rgba(255, 118, 118, 0.45);
        color: #ffc2c2;
      }
      .balance {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-height: 54px;
        padding: 0 20px;
        border-radius: 999px;
        background: #15243a;
        border: 1px solid #2a3d57;
        color: var(--text);
        font-weight: 700;
        font-size: 15px;
        line-height: 1;
        white-space: nowrap;
      }
      .logout {
        color: var(--muted);
        text-decoration: none;
        font-size: 14px;
      }
      .notice {
        background: #172741;
        border: 1px solid #263a56;
        color: var(--muted);
        padding: 12px 16px;
        border-radius: 12px;
        margin-bottom: 18px;
      }
      .grid {
        display: grid;
        grid-template-columns: 1.15fr 1fr;
        gap: 20px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 18px;
        padding: 18px;
      }
      .panel h2 {
        margin: 0 0 12px;
        font-size: 18px;
        color: var(--muted);
      }
      .panel-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 12px;
      }
      .panel-note {
        font-size: 12px;
        color: var(--muted);
        max-width: 360px;
        text-align: right;
      }
      .model-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 6px;
      }
      .model-btn {
        border-radius: 12px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        color: var(--text);
        padding: 10px 12px;
        cursor: pointer;
        font-weight: 600;
      }
      .model-btn.active {
        background: var(--accent);
        color: #261a00;
      }
      .tagline { color: var(--muted); margin: 8px 0 0; font-size: 14px; }
      .field { margin: 14px 0; }
      label { display: block; margin-bottom: 6px; color: var(--muted); font-size: 13px; }
      input[type="text"], textarea {
        width: 100%;
        border-radius: 12px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        color: var(--text);
        padding: 10px 12px;
        font-family: inherit;
        resize: vertical;
      }
      textarea { min-height: 120px; }
      .prompt-field {
        position: relative;
      }
      .prompt-label-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 6px;
      }
      .prompt-label-row label {
        margin-bottom: 0;
      }
      .prompt-helper-btn,
      .prompt-history-btn {
        border-radius: 10px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        color: var(--text);
        padding: 7px 10px;
        font: inherit;
        font-size: 12px;
        cursor: pointer;
        line-height: 1.2;
      }
      .prompt-helper-btn:hover,
      .prompt-helper-btn:focus-visible,
      .prompt-history-btn:hover,
      .prompt-history-btn:focus-visible {
        border-color: var(--accent);
        outline: none;
      }
      .prompt-helper-btn[aria-expanded="true"],
      .prompt-history-btn[aria-expanded="true"] {
        border-color: var(--accent-2);
        background: #112238;
      }
      .prompt-footer {
        margin-top: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .prompt-limit {
        font-size: 12px;
        color: var(--muted);
        text-align: right;
      }
      .prompt-limit.warn {
        color: #f5cc89;
      }
      .prompt-panel {
        position: absolute;
        left: 0;
        right: 0;
        top: calc(100% + 8px);
        border-radius: 12px;
        border: 1px solid #2c4260;
        background: rgba(8, 15, 27, 0.98);
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.35);
        padding: 10px;
        opacity: 0;
        transform: translateY(-6px) scale(0.98);
        transform-origin: top center;
        pointer-events: none;
        transition: opacity 0.16s ease, transform 0.16s ease;
        z-index: 45;
      }
      .prompt-panel.open {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }
      .prompt-panel-title {
        font-size: 12px;
        color: #c2d3e6;
        margin-bottom: 8px;
      }
      .prompt-list {
        max-height: 240px;
        overflow-y: auto;
        display: grid;
        gap: 6px;
      }
      .prompt-list-item {
        width: 100%;
        border-radius: 10px;
        border: 1px solid #2a3d57;
        background: #0f1b2b;
        color: var(--text);
        text-align: left;
        cursor: pointer;
        padding: 9px 10px;
        font: inherit;
        font-size: 13px;
      }
      .prompt-list-item:hover,
      .prompt-list-item:focus-visible {
        border-color: var(--accent-2);
        background: #132540;
        outline: none;
      }
      .prompt-list-item strong {
        display: block;
        margin-bottom: 3px;
      }
      .prompt-list-item span {
        display: block;
        color: var(--muted);
        font-size: 12px;
      }
      .prompt-history-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px;
      }
      .prompt-history-remove {
        width: 30px;
        min-height: 30px;
        border-radius: 8px;
        border: 1px solid #35506f;
        background: #101f34;
        color: #9fb3cc;
        cursor: pointer;
        font-size: 14px;
        line-height: 1;
      }
      .prompt-history-remove:hover,
      .prompt-history-remove:focus-visible {
        border-color: rgba(255, 118, 118, 0.65);
        color: #ffc0c0;
        outline: none;
      }
      .prompt-panel-empty {
        border-radius: 10px;
        border: 1px dashed #2a3d57;
        color: var(--muted);
        font-size: 12px;
        padding: 10px;
      }
      .options-group { margin-top: 12px; }
      .option-title { font-size: 13px; color: var(--muted); margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
      .option-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .option-btn {
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        color: var(--text);
        cursor: pointer;
      }
      .option-btn.active {
        border-color: var(--accent-2);
        background: rgba(64, 212, 154, 0.18);
      }
      .run-row {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-top: 16px;
      }
      .quote-line {
        margin-top: 8px;
        color: var(--muted);
        font-size: 13px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        position: relative;
      }
      .quote-cost {
        color: var(--muted);
      }
      .quote-info-btn {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        border: 1px solid #335171;
        background: #13243a;
        color: #b7cbe2;
        cursor: pointer;
        font-size: 12px;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }
      .quote-info-btn:hover,
      .quote-info-btn:focus-visible {
        border-color: var(--accent);
        color: var(--accent);
        outline: none;
      }
      .quote-tooltip {
        position: absolute;
        top: calc(100% + 8px);
        left: 0;
        min-width: 220px;
        max-width: 300px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid #2c4260;
        background: rgba(9, 17, 30, 0.96);
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.35);
        opacity: 0;
        transform: scale(0.97);
        transform-origin: top left;
        pointer-events: none;
        transition: opacity 0.16s ease, transform 0.16s ease;
        z-index: 40;
      }
      .quote-tooltip.open {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }
      .quote-tooltip-title {
        font-size: 12px;
        color: #c7d8ea;
        margin-bottom: 8px;
      }
      .quote-tooltip-row {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        font-size: 12px;
        color: #a8bfd9;
        margin-top: 5px;
      }
      .quote-tooltip-row.total {
        border-top: 1px solid #29415e;
        margin-top: 8px;
        padding-top: 8px;
        color: #edf4fc;
        font-weight: 700;
      }
      .run-btn {
        background: var(--accent);
        color: #221600;
        border: none;
        padding: 10px 18px;
        border-radius: 12px;
        font-weight: 700;
        cursor: pointer;
      }
      .run-btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .status { font-size: 12px; color: var(--muted); margin-top: 8px; }
      .status.error { color: var(--danger); }
      .status.success { color: var(--accent-2); }
      .gen-live {
        margin-top: 10px;
        border-radius: 12px;
        border: 1px solid #29415e;
        background: #0f1b2b;
        padding: 10px 12px;
        display: none;
      }
      .gen-live.visible {
        display: block;
      }
      .gen-live-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }
      .gen-live-line {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }
      .gen-live-spinner {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid #2f4e72;
        border-top-color: #9fc2e6;
        animation: gen-spin 0.9s linear infinite;
        flex: 0 0 auto;
      }
      .gen-live-spinner.hidden {
        display: none;
      }
      .gen-live-text {
        font-size: 13px;
        color: #d6e4f4;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .gen-live-eta {
        font-size: 12px;
        color: #93abc7;
      }
      .gen-live-sub {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
      }
      .gen-live.error {
        border-color: rgba(255, 118, 118, 0.5);
      }
      .gen-live.error .gen-live-text,
      .gen-live.error .gen-live-sub {
        color: #ffc6c6;
      }
      .gen-live.warning {
        border-color: rgba(245, 185, 79, 0.5);
      }
      .gen-live.warning .gen-live-text {
        color: #ffd89d;
      }
      .gen-cancel-btn {
        border-radius: 9px;
        border: 1px solid #35506f;
        background: #13243a;
        color: #d3e3f5;
        padding: 6px 10px;
        font: inherit;
        font-size: 12px;
        cursor: pointer;
      }
      .gen-cancel-btn:hover,
      .gen-cancel-btn:focus-visible {
        border-color: rgba(255, 118, 118, 0.55);
        color: #ffc0c0;
        outline: none;
      }
      .gen-cancel-btn.hidden {
        display: none;
      }
      .gen-lock-target.locked {
        opacity: 0.6;
        pointer-events: none;
        user-select: none;
      }
      .ui-toast {
        position: fixed;
        right: 16px;
        bottom: 16px;
        z-index: 100;
        border-radius: 10px;
        border: 1px solid #2d4563;
        background: rgba(10, 18, 30, 0.96);
        color: #dce9f8;
        padding: 9px 12px;
        font-size: 12px;
        opacity: 0;
        transform: translateY(6px);
        pointer-events: none;
        transition: opacity 0.16s ease, transform 0.16s ease;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
      }
      .ui-toast.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .ui-toast.warning {
        border-color: rgba(245, 185, 79, 0.5);
        color: #ffd89d;
      }
      .ui-toast.error {
        border-color: rgba(255, 118, 118, 0.5);
        color: #ffc4c4;
      }
      @keyframes gen-spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      .confirm-modal {
        position: fixed;
        inset: 0;
        background: rgba(6, 11, 18, 0.72);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        z-index: 80;
      }
      .confirm-modal.open {
        display: flex;
        animation: overlay-in 0.14s ease;
      }
      .confirm-modal-card {
        width: min(420px, 100%);
        border-radius: 16px;
        border: 1px solid #2a3f5a;
        background: #111d2f;
        box-shadow: 0 22px 54px rgba(0, 0, 0, 0.45);
        padding: 18px;
        animation: modal-in 0.16s ease;
      }
      .confirm-title {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 8px;
      }
      .confirm-text {
        color: var(--muted);
        font-size: 14px;
        line-height: 1.5;
      }
      .confirm-check {
        margin-top: 12px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: #bed0e4;
        font-size: 13px;
        user-select: none;
        cursor: pointer;
      }
      .confirm-check input {
        margin: 0;
      }
      .confirm-check.disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .confirm-actions {
        margin-top: 16px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }
      .confirm-btn {
        border-radius: 10px;
        border: 1px solid #2b3f59;
        background: #13243a;
        color: var(--text);
        font: inherit;
        padding: 9px 14px;
        cursor: pointer;
        font-weight: 600;
      }
      .confirm-btn.ghost:hover {
        border-color: #415f86;
      }
      .confirm-btn.primary {
        border-color: #7d5e18;
        background: linear-gradient(135deg, #f5b94f 0%, #e2a336 100%);
        color: #241900;
      }
      .output-preview {
        border-radius: 14px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        padding: 14px;
        min-height: 220px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .output-view-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        margin: 0 0 10px;
      }
      .view-toggle-btn {
        border-radius: 999px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        color: var(--text);
        padding: 6px 11px;
        font: inherit;
        font-size: 12px;
        cursor: pointer;
      }
      .view-toggle-btn.active {
        border-color: #4f6f96;
        background: #152742;
      }
      .gallery {
        position: relative;
        border-radius: 16px;
        border: 1px solid #243652;
        background: #0c1626;
        overflow: hidden;
        min-height: 360px;
        aspect-ratio: 1 / 1;
      }
      .gallery img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      .gallery-empty {
        padding: 24px;
        color: var(--muted);
        text-align: center;
        white-space: pre-line;
      }
      .gallery-badge {
        position: absolute;
        top: 12px;
        right: 12px;
        background: rgba(15, 27, 43, 0.85);
        border: 1px solid #2b3f59;
        color: var(--text);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
      }
      .gallery-count {
        position: absolute;
        top: 12px;
        left: 12px;
        background: rgba(15, 27, 43, 0.85);
        border: 1px solid #2b3f59;
        color: var(--text);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
      }
      .gallery-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 1px solid #2b3f59;
        background: rgba(15, 27, 43, 0.85);
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .gallery-nav.prev { left: 12px; }
      .gallery-nav.next { right: 12px; }
      .gallery-actions {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .result-actions {
        flex-wrap: wrap;
      }
      .action-btn {
        border-radius: 10px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        color: var(--text);
        padding: 8px 12px;
        cursor: pointer;
        text-decoration: none;
        display: inline-flex;
        gap: 6px;
        align-items: center;
      }
      .action-btn:hover,
      .action-btn:focus-visible {
        border-color: #48698f;
        outline: none;
      }
      .action-btn.favorited {
        border-color: #7a6632;
        color: #ffd276;
        background: rgba(88, 69, 25, 0.45);
      }
      .action-btn.danger {
        border-color: rgba(255, 118, 118, 0.5);
        color: var(--danger);
      }
      .gallery-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 10px;
      }
      .gallery-card {
        border-radius: 12px;
        border: 1px solid #2b3f59;
        background: #0f1b2b;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 7px;
      }
      .gallery-card.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(245, 185, 79, 0.25);
      }
      .gallery-card-main {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid #27425f;
        background: #0a1524;
        cursor: pointer;
      }
      .gallery-card-main img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .gallery-card-meta {
        font-size: 11px;
        color: var(--muted);
      }
      .gallery-card-actions {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 6px;
      }
      .gallery-card-actions .action-btn {
        justify-content: center;
        font-size: 11px;
        padding: 7px 8px;
      }
      .result-skeleton {
        border-radius: 12px;
        border: 1px solid #253a54;
        background: #0f1b2b;
        padding: 8px;
      }
      .result-skeleton-img {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 10px;
        background: linear-gradient(90deg, #16273f 20%, #1f3350 50%, #16273f 80%);
        background-size: 220% 100%;
        animation: skeleton-shift 1.2s ease-in-out infinite;
      }
      .result-skeleton-line {
        margin-top: 7px;
        height: 10px;
        border-radius: 8px;
        background: linear-gradient(90deg, #16273f 20%, #1f3350 50%, #16273f 80%);
        background-size: 220% 100%;
        animation: skeleton-shift 1.2s ease-in-out infinite;
      }
      .result-skeleton-line.short {
        width: 60%;
      }
      @keyframes skeleton-shift {
        from { background-position: 200% 0; }
        to { background-position: -20% 0; }
      }
      .edit-model-modal {
        position: fixed;
        inset: 0;
        background: rgba(6, 11, 18, 0.72);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        z-index: 85;
      }
      .edit-model-modal.open {
        display: flex;
        animation: overlay-in 0.14s ease;
      }
      .edit-model-card {
        width: min(360px, 100%);
        border-radius: 14px;
        border: 1px solid #2f4868;
        background: #0f1b2b;
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.42);
        padding: 14px;
        animation: modal-in 0.16s ease;
      }
      .edit-model-title {
        font-size: 14px;
        color: #d7e6f7;
        margin-bottom: 8px;
        font-weight: 600;
      }
      .edit-model-list {
        display: grid;
        gap: 6px;
      }
      .edit-model-btn {
        border-radius: 10px;
        border: 1px solid #2b3f59;
        background: #13243a;
        color: var(--text);
        text-align: left;
        padding: 9px 10px;
        font: inherit;
        cursor: pointer;
      }
      .edit-model-btn:hover,
      .edit-model-btn:focus-visible {
        border-color: var(--accent-2);
        outline: none;
      }
      .edit-model-empty {
        border-radius: 10px;
        border: 1px dashed #2a3d57;
        color: var(--muted);
        padding: 10px;
        font-size: 12px;
      }
      .thumbs-wrap {
        position: relative;
        padding: 0 34px;
      }
      .thumbs {
        display: grid;
        grid-template-columns: repeat(1, minmax(0, 1fr));
        gap: 8px;
      }
      .thumbs-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 1px solid #2b3f59;
        background: rgba(15, 27, 43, 0.9);
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .thumbs-nav.prev { left: 0; }
      .thumbs-nav.next { right: 0; }
      .thumbs-nav:disabled {
        opacity: 0.4;
        cursor: default;
      }
      .thumb {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 10px;
        border: 1px solid #2b3f59;
        overflow: hidden;
        cursor: pointer;
        background: #0f1b2b;
        transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
      }
      .thumb:hover {
        transform: translateY(-1px);
        border-color: #3f5d84;
      }
      .thumb.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(245, 185, 79, 0.35);
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .thumbs-pages {
        margin-top: 6px;
        text-align: right;
        color: var(--muted);
        font-size: 12px;
      }
      .redeem-panel {
        padding: 0;
      }
      .redeem-toggle {
        width: 100%;
        border: none;
        background: transparent;
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        padding: 16px 18px;
        cursor: pointer;
      }
      .redeem-title {
        font-size: 18px;
        color: var(--muted);
        font-weight: 600;
      }
      .redeem-chevron {
        color: var(--muted);
        font-size: 16px;
        line-height: 1;
        transition: transform 0.25s ease, color 0.25s ease;
      }
      .redeem-toggle[aria-expanded="true"] .redeem-chevron {
        transform: rotate(180deg);
        color: var(--accent);
      }
      .redeem-content {
        max-height: 0;
        opacity: 0;
        overflow: hidden;
        transition: max-height 0.28s ease, opacity 0.2s ease;
      }
      .redeem-content.open {
        max-height: 360px;
        opacity: 1;
      }
      .redeem-content-inner {
        padding: 0 18px 18px;
      }
      .redeem-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
      }
      .promo-input {
        background: #162741;
        border-color: #35547a;
        color: var(--text);
        caret-color: var(--text);
      }
      .promo-input::placeholder {
        color: var(--muted);
        opacity: 1;
      }
      .promo-input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(245, 185, 79, 0.18);
      }
      .promo-btn {
        border: 1px solid #2b3f59;
        background: linear-gradient(135deg, #f5b94f 0%, #df9f2c 100%);
        color: #2a1b00;
        border-radius: 12px;
        padding: 10px 14px;
        font-weight: 700;
        cursor: pointer;
        white-space: nowrap;
      }
      .promo-btn:hover {
        filter: brightness(1.04);
      }
      .crypto-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
      }
      .crypto-package-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
        gap: 10px;
        margin-bottom: 10px;
      }
      .crypto-package-card {
        border: 1px solid #2f496a;
        border-radius: 14px;
        padding: 10px;
        background: #102038;
        color: var(--text);
        text-align: left;
        cursor: pointer;
        transition: border-color 0.18s ease, transform 0.18s ease, box-shadow 0.18s ease;
      }
      .crypto-package-card:hover {
        border-color: #4f6f96;
      }
      .crypto-package-card.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px rgba(245, 185, 79, 0.24), 0 8px 18px rgba(8, 18, 32, 0.35);
        transform: translateY(-1px);
      }
      .crypto-package-head {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        align-items: flex-start;
        margin-bottom: 6px;
      }
      .crypto-package-title {
        font-weight: 700;
        font-size: 14px;
        line-height: 1.2;
      }
      .crypto-package-badges {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 6px;
      }
      .crypto-badge {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        border-radius: 999px;
        padding: 2px 7px;
        font-size: 11px;
        line-height: 1.2;
        border: 1px solid #365377;
        color: #a9c2df;
        background: rgba(26, 45, 68, 0.9);
      }
      .crypto-badge.best {
        border-color: #3f7a5e;
        color: #7ef0b7;
        background: rgba(26, 63, 48, 0.7);
      }
      .crypto-badge.save {
        border-color: #7a6632;
        color: #ffd276;
        background: rgba(88, 69, 25, 0.52);
      }
      .crypto-package-line {
        color: var(--muted);
        font-size: 12px;
      }
      .crypto-package-price {
        margin-top: 7px;
        font-size: 15px;
        font-weight: 700;
      }
      .crypto-select {
        width: 100%;
        border-radius: 12px;
        border: 1px solid #35547a;
        background: #162741;
        color: var(--text);
        padding: 10px 12px;
        font-family: inherit;
      }
      .crypto-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(245, 185, 79, 0.18);
      }
      .crypto-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .visually-hidden {
        position: absolute !important;
        width: 1px !important;
        height: 1px !important;
        padding: 0 !important;
        margin: -1px !important;
        overflow: hidden !important;
        clip: rect(0, 0, 0, 0) !important;
        white-space: nowrap !important;
        border: 0 !important;
      }
      .ref-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 10px;
        color: var(--muted);
        font-size: 14px;
      }
      .ref-title {
        font-weight: 600;
        color: var(--text);
      }
      .ref-sub {
        color: var(--muted);
      }
      .ref-input {
        display: none;
      }
      .ref-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
        margin-bottom: 8px;
      }
      .field.ref-drop-active .ref-grid {
        border: 1px dashed rgba(64, 212, 154, 0.85);
        border-radius: 16px;
        padding: 8px;
        background: rgba(64, 212, 154, 0.08);
      }
      .ref-tile {
        aspect-ratio: 1 / 1;
        border-radius: 16px;
        border: 1px dashed #f5b94f;
        background: #0f1b2b;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        text-align: center;
        color: var(--muted);
        cursor: pointer;
      }
      .ref-add-icon {
        width: 36px;
        height: 36px;
        border-radius: 12px;
        background: rgba(245, 185, 79, 0.18);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--accent);
        font-size: 18px;
      }
      .ref-tile strong {
        color: var(--text);
      }
      .field.ref-drop-active .ref-tile {
        border-color: rgba(64, 212, 154, 0.9);
      }
      .ref-thumb {
        position: relative;
        aspect-ratio: 1 / 1;
        border-radius: 16px;
        border: 1px solid #2b3f59;
        overflow: hidden;
        background: #0f1b2b;
      }
      .ref-thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: center;
        display: block;
      }
      .ref-remove {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 26px;
        height: 26px;
        border-radius: 50%;
        border: none;
        background: rgba(15, 27, 43, 0.9);
        color: var(--text);
        cursor: pointer;
        font-weight: 700;
      }
      .ref-replace {
        position: absolute;
        top: 8px;
        left: 8px;
        height: 26px;
        border-radius: 999px;
        border: none;
        background: rgba(15, 27, 43, 0.9);
        color: var(--text);
        cursor: pointer;
        font-weight: 600;
        font-size: 12px;
        padding: 0 10px;
      }
      .ref-note {
        color: var(--muted);
        font-size: 12px;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        padding: 4px 8px;
        border-radius: 999px;
        background: #1a2b45;
        border: 1px solid #2a3d57;
        font-size: 11px;
        color: var(--muted);
      }
      .topup-modal {
        position: fixed;
        inset: 0;
        background: rgba(5, 11, 19, 0.72);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        z-index: 60;
      }
      .topup-modal.open {
        display: flex;
      }
      .topup-modal-card {
        width: min(560px, 100%);
        border-radius: 18px;
        border: 1px solid #2a3d57;
        background: #111f33;
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.4);
        overflow: hidden;
        animation: modal-in 0.18s ease;
      }
      .topup-modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 14px 16px;
        border-bottom: 1px solid #243652;
      }
      .topup-modal-title {
        font-size: 18px;
        font-weight: 700;
      }
      .topup-modal-close {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        border: 1px solid #2a3d57;
        background: #0f1b2b;
        color: var(--text);
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
      }
      .topup-modal-body {
        padding: 16px;
      }
      .topup-section {
        display: none;
      }
      .topup-section.active {
        display: block;
      }
      @keyframes modal-in {
        from { opacity: 0; transform: translateY(10px) scale(0.98); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      @media (max-width: 980px) {
        body {
          padding: 14px;
        }
        .grid {
          grid-template-columns: 1fr;
          gap: 14px;
        }
        .topbar {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
        }
        .top-actions {
          width: 100%;
          justify-content: space-between;
          flex-wrap: wrap;
          gap: 8px;
        }
        .lang-menu {
          width: 100%;
        }
        .topup-menu {
          width: 100%;
        }
        .lang-button {
          width: 100%;
          justify-content: space-between;
        }
        .topup-button {
          width: 100%;
          justify-content: space-between;
        }
        .lang-dropdown {
          right: 0;
          top: calc(100% + 6px);
          min-width: 100%;
        }
        .topup-dropdown {
          right: 0;
          width: 100%;
        }
        .balance {
          width: 100%;
          justify-content: center;
        }
        .user-menu {
          width: 100%;
        }
        .user-button {
          width: 100%;
          justify-content: flex-start;
        }
        .user-name {
          max-width: none;
        }
        .user-dropdown {
          right: 0;
          top: calc(100% + 6px);
          min-width: 100%;
        }
        .panel {
          padding: 14px;
        }
        .panel-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 6px;
        }
        .panel-note {
          text-align: left;
          max-width: none;
        }
        .gallery {
          min-height: 240px;
        }
        .gallery-nav {
          width: 34px;
          height: 34px;
        }
        .gallery-nav.prev { left: 8px; }
        .gallery-nav.next { right: 8px; }
        .gallery-badge,
        .gallery-count {
          font-size: 11px;
          padding: 5px 8px;
        }
        .gallery-actions {
          flex-wrap: wrap;
        }
        .action-btn {
          flex: 1 1 calc(50% - 5px);
          justify-content: center;
        }
        .gallery-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
        .gallery-card-actions {
          grid-template-columns: 1fr;
        }
        .thumbs-wrap {
          padding: 0 28px;
        }
        .ref-grid {
          grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
          gap: 10px;
        }
        .ref-header {
          flex-wrap: wrap;
          row-gap: 2px;
        }
        .run-row {
          flex-direction: column;
          align-items: stretch;
          gap: 8px;
        }
        .prompt-label-row {
          flex-wrap: wrap;
        }
        .prompt-helper-btn {
          width: 100%;
        }
        .prompt-footer {
          flex-direction: column;
          align-items: stretch;
          gap: 8px;
        }
        .prompt-history-btn {
          width: 100%;
        }
        .prompt-limit {
          text-align: left;
        }
        .quote-line {
          display: flex;
          flex-wrap: wrap;
        }
        .run-btn {
          width: 100%;
        }
        .gen-live-main {
          flex-direction: column;
          align-items: flex-start;
        }
        .redeem-row { grid-template-columns: 1fr; }
        .promo-btn { width: 100%; }
        .crypto-row { grid-template-columns: 1fr; }
        .crypto-package-list {
          grid-template-columns: 1fr;
        }
        .redeem-content.open { max-height: 420px; }
        .site-logo {
          width: 40px;
          height: 40px;
        }
      }
      @media (max-width: 600px) {
        .brand {
          font-size: 22px;
        }
        .subtitle {
          font-size: 13px;
        }
        .model-buttons {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 8px;
        }
        .model-btn {
          width: 100%;
          text-align: center;
        }
        .option-buttons {
          display: grid;
          grid-template-columns: 1fr 1fr;
          gap: 8px;
        }
        .option-btn {
          width: 100%;
          text-align: center;
        }
        .thumbs-wrap {
          padding: 0 24px;
        }
        .thumbs-nav {
          width: 28px;
          height: 28px;
        }
        .action-btn {
          flex: 1 1 100%;
        }
        .gallery-grid {
          grid-template-columns: 1fr;
        }
        .output-view-toggle {
          width: 100%;
        }
        .view-toggle-btn {
          flex: 1 1 0;
          text-align: center;
        }
        .prompt-panel {
          top: calc(100% + 6px);
        }
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="brand-wrap">
        <img
          class="site-logo"
          src="{{ site_logo_url or '/assets/site-logo' }}"
          alt="{{ labels['site_title'] }} logo"
          onerror="this.style.display='none';"
        />
        <div class="brand-text">
          <div class="brand">{{ labels['site_title'] }}</div>
          <div class="subtitle">{{ labels['site_tagline'] }}</div>
        </div>
      </div>
      <div class="top-actions">
        <div class="lang-menu" id="langMenu">
          <button class="lang-button" id="langButton" type="button" aria-haspopup="true" aria-expanded="false">
            <span class="lang-icon">🌐</span>
            <span class="lang-name">{{ labels['language'] }}: {{ current_lang_label }}</span>
            <span class="user-caret">▾</span>
          </button>
          <div class="lang-dropdown" id="langDropdown">
            {% for option in lang_options %}
              <a
                href="/set-lang?lang={{ option.code }}&next={{ request.url.path }}"
                class="{% if option.code == lang %}active{% endif %}">
                {{ option.label }}
              </a>
            {% endfor %}
          </div>
        </div>
        {% if logged_in %}
          <div class="balance" id="balanceLabel">--</div>
          <div class="topup-menu" id="topupMenu">
            <button class="topup-button" id="topupButton" type="button" aria-haspopup="true" aria-expanded="false">
              <span>💳 {{ labels['topup_button'] }}</span>
              <span class="user-caret">▾</span>
            </button>
            <div class="topup-dropdown" id="topupDropdown">
              <button class="topup-item" id="topupRedeemOption" type="button">🎟️ {{ labels['topup_redeem_option'] }}</button>
              <button class="topup-item" id="topupStarsOption" type="button">⭐ {{ labels['topup_stars_option'] }}</button>
              <button class="topup-item" id="topupCryptoOption" type="button">{{ labels['topup_crypto_option'] }}</button>
            </div>
          </div>
          <div class="user-menu" id="userMenu">
            <button class="user-button" id="userButton" type="button" aria-haspopup="true" aria-expanded="false">
              <div class="user-avatar" id="userAvatar">R</div>
              <div class="user-name" id="userName">User</div>
              <div class="user-caret">▾</div>
            </button>
            <div class="user-dropdown" id="userDropdown">
              <label class="user-setting" for="skipConfirmToggle">
                <input id="skipConfirmToggle" type="checkbox" />
                <span>{{ labels['confirm_skip_toggle'] }}</span>
              </label>
              <a href="/logout">{{ labels['logout'] }}</a>
            </div>
          </div>
        {% else %}
          <div class="miniapp-auth-note" id="miniAppAuthNotice"></div>
          <div class="login-widget" id="loginWidget">
            <script
              async
              src="https://telegram.org/js/telegram-widget.js?22"
              data-telegram-login="{{ bot_username }}"
              data-lang="en"
              data-size="large"
              data-onauth="onTelegramAuth(user)"
              data-request-access="write">
            </script>
          </div>
        {% endif %}
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>{{ labels['input_title'] }}</h2>
        <div class="model-buttons gen-lock-target" id="modelButtons"></div>
        <div class="tagline" id="modelTagline"></div>

        <div class="field prompt-field gen-lock-target" id="promptField">
          <div class="prompt-label-row">
            <label for="prompt">{{ labels['prompt_label'] }}</label>
            <button
              class="prompt-helper-btn"
              id="promptHelperBtn"
              type="button"
              aria-haspopup="dialog"
              aria-expanded="false"
            >
              ✨ {{ labels['prompt_helper_button'] }}
            </button>
          </div>
          <textarea id="prompt" placeholder="{{ labels['prompt_placeholder'] }}"></textarea>
          <div class="prompt-footer">
            <button
              class="prompt-history-btn"
              id="promptHistoryBtn"
              type="button"
              aria-haspopup="dialog"
              aria-expanded="false"
            >
              ↓ {{ labels['prompt_history_button'] }}
            </button>
            <div class="prompt-limit" id="promptLimitHint" aria-live="polite"></div>
          </div>
          <div class="prompt-panel" id="promptHelperPanel" role="dialog" aria-hidden="true">
            <div class="prompt-panel-title">{{ labels['prompt_helper_title'] }}</div>
            <div class="prompt-list" id="promptHelperList"></div>
          </div>
          <div class="prompt-panel" id="promptHistoryPanel" role="dialog" aria-hidden="true">
            <div class="prompt-panel-title">{{ labels['prompt_history_title'] }}</div>
            <div class="prompt-list" id="promptHistoryList"></div>
          </div>
        </div>

        <div class="field gen-lock-target" id="uploadBlock">
          <div class="ref-header">
            <div class="ref-title" id="refTitle"></div>
            <div class="ref-sub" id="refSub"></div>
          </div>
          <input id="refFiles" class="ref-input" type="file" multiple accept="image/*" />
          <input id="refReplaceFile" class="ref-input" type="file" accept="image/*" />
          <div class="ref-grid" id="refGrid"></div>
          <div class="ref-note" id="refNote"></div>
        </div>

        <div class="field gen-lock-target" id="optionsContainer">
          <label>{{ labels['options_label'] }}</label>
        </div>

        <div class="run-row">
          <button class="run-btn" id="runBtn">{{ labels['run'] }}</button>
          <div class="status" id="runStatus"></div>
        </div>
        <div class="gen-live" id="genLive" aria-live="polite">
          <div class="gen-live-main">
            <div class="gen-live-line">
              <span class="gen-live-spinner" id="genLiveSpinner" aria-hidden="true"></span>
              <span class="gen-live-text" id="genLiveText"></span>
              <span class="gen-live-eta" id="genLiveEta"></span>
            </div>
            <button class="gen-cancel-btn hidden" id="genCancelBtn" type="button">{{ labels['gen_cancel'] }}</button>
          </div>
          <div class="gen-live-sub" id="genLiveSub"></div>
        </div>
        <div class="quote-line" id="quoteLine">
          <span class="quote-cost" id="quoteCostText"></span>
          <button
            class="quote-info-btn"
            id="quoteInfoBtn"
            type="button"
            aria-label="{{ labels['quote_info_title'] }}"
            aria-expanded="false"
            aria-haspopup="dialog"
            style="display:none;"
          >
            {{ labels['quote_info'] }}
          </button>
          <div class="quote-tooltip" id="quoteTooltip" role="dialog" aria-hidden="true"></div>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h2>{{ labels['output_title'] }}</h2>
          <div class="panel-note">{{ labels['site_notice'] }}</div>
        </div>
        <div class="output-view-toggle" id="outputViewToggle" style="display:none;">
          <button id="viewCarouselBtn" class="view-toggle-btn active" type="button">{{ labels['result_view_carousel'] }}</button>
          <button id="viewGridBtn" class="view-toggle-btn" type="button">{{ labels['result_view_grid'] }}</button>
        </div>
        <div class="output-preview" id="outputPreview">
          <div class="gallery" id="gallery">
            <div class="gallery-empty">{{ labels['output_empty_hint'] }}</div>
          </div>
          <div class="gallery-grid" id="galleryGrid" style="display:none;"></div>
          <div class="gallery-actions result-actions" id="galleryActions" style="display:none;">
            <a class="action-btn" id="downloadBtn" href="#" download>
              ⬇ {{ labels['result_download'] }}
            </a>
            <button class="action-btn" id="regenerateBtn">🔁 {{ labels['result_regenerate'] }}</button>
            <button class="action-btn" id="editPromptBtn">✏ {{ labels['result_edit_prompt'] }}</button>
            <button class="action-btn" id="editWithAiBtn">🧩 {{ labels['result_edit_ai'] }}</button>
            <button class="action-btn" id="favoriteBtn">⭐ {{ labels['result_favorite_add'] }}</button>
          </div>
          <div class="thumbs-wrap" id="thumbsWrap">
            <button class="thumbs-nav prev" id="thumbsPrev" type="button" aria-label="Previous thumbnails">‹</button>
            <div class="thumbs" id="thumbs"></div>
            <button class="thumbs-nav next" id="thumbsNext" type="button" aria-label="Next thumbnails">›</button>
          </div>
          <div class="thumbs-pages" id="thumbsPages" style="display:none;"></div>
        </div>
      </div>
    </div>

    {% if logged_in %}
      <div class="topup-modal" id="topupModal" aria-hidden="true">
        <div class="topup-modal-card" role="dialog" aria-modal="true" aria-labelledby="topupModalTitle">
          <div class="topup-modal-header">
            <div class="topup-modal-title" id="topupModalTitle"></div>
            <button class="topup-modal-close" id="topupModalClose" type="button" aria-label="Close">×</button>
          </div>
          <div class="topup-modal-body">
            <div class="topup-section" id="topupSectionRedeem">
              <div class="redeem-row">
                <input id="promoInput" type="text" class="promo-input" placeholder="{{ labels['redeem_placeholder'] }}" />
                <button id="promoBtn" class="promo-btn">{{ labels['redeem_button'] }}</button>
              </div>
              <div class="status" id="promoStatus"></div>
            </div>
            <div class="topup-section" id="topupSectionCrypto">
              <div class="crypto-package-list" id="cryptoPackageList"></div>
              <div class="crypto-row">
                <select id="cryptoPackage" class="crypto-select visually-hidden" aria-label="{{ labels['crypto_select_package'] }}"></select>
                <button id="cryptoCreateBtn" class="promo-btn" type="button">{{ labels['crypto_create_invoice'] }}</button>
              </div>
              <div class="crypto-actions">
                <a id="cryptoPayLink" class="action-btn" href="#" target="_blank" rel="noopener" style="display:none;">
                  💸 {{ labels['crypto_open_invoice'] }}
                </a>
                <button id="cryptoCheckBtn" class="action-btn" type="button" disabled>
                  🔄 {{ labels['crypto_check_status'] }}
                </button>
              </div>
              <div class="status" id="cryptoStatus"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="confirm-modal" id="confirmModal" aria-hidden="true">
        <div class="confirm-modal-card" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
          <div class="confirm-title" id="confirmTitle">{{ labels['confirm_title'] }}</div>
          <div class="confirm-text" id="confirmText"></div>
          <label class="confirm-check" id="confirmDontShowWrap" for="confirmDontShowCheckbox">
            <input id="confirmDontShowCheckbox" type="checkbox" />
            <span>{{ labels['confirm_dont_show_again'] }}</span>
          </label>
          <div class="confirm-actions">
            <button class="confirm-btn ghost" id="confirmCancelBtn" type="button">{{ labels['confirm_cancel'] }}</button>
            <button class="confirm-btn primary" id="confirmOkBtn" type="button">{{ labels['confirm_continue'] }}</button>
          </div>
        </div>
      </div>

      <div class="edit-model-modal" id="editModelModal" aria-hidden="true">
        <div class="edit-model-card" role="dialog" aria-modal="true" aria-labelledby="editModelTitle">
          <div class="edit-model-title" id="editModelTitle">{{ labels['result_edit_with_title'] }}</div>
          <div class="edit-model-list" id="editModelList"></div>
        </div>
      </div>
    {% endif %}
    <div class="ui-toast" id="uiToast"></div>

    <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
    <script>
      const labels = {{ labels | tojson }};
      const loggedIn = {{ 'true' if logged_in else 'false' }};
      const botUsername = {{ bot_username | tojson }};
      const maxPromptLength = Number({{ max_prompt_length | tojson }}) || 0;
      let models = [];
      let currentModel = null;
      let optionsState = {};
      let maxOutputs = 1;
      let galleryItems = [];
      let galleryIndex = 0;
      let galleryMode = 'carousel';
      let pendingSkeletonCount = 0;
      let resultSkeletonActive = false;
      let thumbsPage = 0;
      let modelNames = {};
      let selectedFiles = [];
      let refPreviews = [];
      let favorites = [];
      let editWithAiSourceItem = null;
      let cryptoPackages = [];
      let cryptoInvoiceUuid = '';
      let cryptoInvoiceCredits = 0;
      let cryptoPollTimer = null;
      let cryptoPollBusy = false;
      let cryptoPollAttempts = 0;
      let currentBalance = 0;
      let generationCount = 0;
      let quoteData = null;
      let runInProgress = false;
      let generationInFlight = false;
      let confirmModalOpen = false;
      let quoteTooltipOpen = false;
      let toastTimer = null;
      const THUMB_ROWS = 3;
      const NEW_USER_CONFIRM_REQUIRED_COUNT = 5;
      const GENERATION_STATUS_POLL_BASE_MS = 2200;
      const GENERATION_STATUS_POLL_MAX_MS = 15000;
      const GENERATION_LONG_WAIT_MS = 180000;
      const SKIP_CONFIRM_STORAGE_KEY = 'renderis.skip_confirm_generation';
      const FAVORITES_STORAGE_KEY = 'renderis.favorites.v1';
      const FAVORITES_MAX_ITEMS = 20;
      const PROMPT_HISTORY_STORAGE_KEY = 'renderis.prompt_history.v1';
      const PROMPT_HISTORY_LIMIT = 10;
      const PROMPT_TEMPLATES = [
        {
          id: 'logo_brand_mark',
          title: labels.prompt_template_logo_title,
          text: labels.prompt_template_logo_text,
        },
        {
          id: 'social_media_post',
          title: labels.prompt_template_social_title,
          text: labels.prompt_template_social_text,
        },
        {
          id: 'cinematic_scene',
          title: labels.prompt_template_cinematic_title,
          text: labels.prompt_template_cinematic_text,
        },
        {
          id: 'product_mockup',
          title: labels.prompt_template_product_title,
          text: labels.prompt_template_product_text,
        },
        {
          id: 'minimal_icon',
          title: labels.prompt_template_icon_title,
          text: labels.prompt_template_icon_text,
        },
        {
          id: 'photorealistic_portrait',
          title: labels.prompt_template_portrait_title,
          text: labels.prompt_template_portrait_text,
        },
      ];
      let promptHistory = [];
      const tgWebApp = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
      const isMiniApp = Boolean(tgWebApp && typeof tgWebApp.initData === 'string');
      const loginWidget = document.getElementById('loginWidget');
      const miniAppAuthNotice = document.getElementById('miniAppAuthNotice');

      function setMiniAppAuthNotice(text, tone = '') {
        if (!miniAppAuthNotice) return;
        miniAppAuthNotice.classList.remove('error');
        if (tone === 'error') {
          miniAppAuthNotice.classList.add('error');
        }
        miniAppAuthNotice.textContent = text || '';
        miniAppAuthNotice.style.display = text ? 'block' : 'none';
      }

      function openExternalLink(url) {
        if (!url) return;
        if (isMiniApp && tgWebApp && typeof tgWebApp.openLink === 'function') {
          tgWebApp.openLink(url);
          return;
        }
        window.open(url, '_blank', 'noopener');
      }

      function openTelegramDeepLink(url) {
        if (!url) return;
        if (isMiniApp && tgWebApp && typeof tgWebApp.openTelegramLink === 'function') {
          tgWebApp.openTelegramLink(url);
          return;
        }
        window.location.href = url;
      }

      function fmt(template, params = {}) {
        let out = template || '';
        Object.keys(params).forEach((k) => {
          out = out.replaceAll(`{${k}}`, params[k]);
        });
        return out;
      }

      function escapeHtml(value) {
        return String(value || '')
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#39;');
      }

      function trackUiEvent(eventName, payload = {}) {
        const detail = { event: eventName, ...payload };
        try {
          if (Array.isArray(window.dataLayer)) {
            window.dataLayer.push(detail);
          }
          if (typeof window.gtag === 'function') {
            window.gtag('event', eventName, payload);
          }
          window.dispatchEvent(new CustomEvent('renderis:analytics', { detail }));
        } catch (e) {
          // Keep analytics best-effort and non-blocking.
        }
      }

      function getPromptInput() {
        return document.getElementById('prompt');
      }

      function isPromptUiTarget(target) {
        const field = document.getElementById('promptField');
        return !!(field && target instanceof Node && field.contains(target));
      }

      function closePromptPanels() {
        const helperPanel = document.getElementById('promptHelperPanel');
        const historyPanel = document.getElementById('promptHistoryPanel');
        const helperBtn = document.getElementById('promptHelperBtn');
        const historyBtn = document.getElementById('promptHistoryBtn');
        if (helperPanel) {
          helperPanel.classList.remove('open');
          helperPanel.setAttribute('aria-hidden', 'true');
        }
        if (historyPanel) {
          historyPanel.classList.remove('open');
          historyPanel.setAttribute('aria-hidden', 'true');
        }
        if (helperBtn) {
          helperBtn.setAttribute('aria-expanded', 'false');
        }
        if (historyBtn) {
          historyBtn.setAttribute('aria-expanded', 'false');
        }
      }

      function openPromptPanel(panelId, buttonId) {
        const panel = document.getElementById(panelId);
        const btn = document.getElementById(buttonId);
        if (!panel || !btn) return;
        const isOpen = panel.classList.contains('open');
        closePromptPanels();
        if (isOpen) return;
        panel.classList.add('open');
        panel.setAttribute('aria-hidden', 'false');
        btn.setAttribute('aria-expanded', 'true');
        const firstAction = panel.querySelector('button.prompt-list-item');
        if (firstAction) {
          setTimeout(() => firstAction.focus(), 20);
        }
      }

      function updatePromptLengthHint() {
        const hintEl = document.getElementById('promptLimitHint');
        const promptEl = getPromptInput();
        if (!hintEl || !promptEl) return;
        if (!maxPromptLength || maxPromptLength <= 0) {
          hintEl.textContent = '';
          hintEl.classList.remove('warn');
          return;
        }
        const count = promptEl.value.length;
        const exceeds = count > maxPromptLength;
        hintEl.textContent = fmt(labels.prompt_length_hint, { count, max: maxPromptLength });
        hintEl.classList.toggle('warn', exceeds);
      }

      function insertIntoPrompt(text) {
        const promptEl = getPromptInput();
        if (!promptEl) return;
        const insertText = String(text || '');
        const start = Number.isInteger(promptEl.selectionStart) ? promptEl.selectionStart : promptEl.value.length;
        const before = promptEl.value.slice(0, start);
        const after = promptEl.value.slice(start);
        promptEl.value = `${before}${insertText}${after}`;
        const nextPos = start + insertText.length;
        promptEl.focus();
        promptEl.setSelectionRange(nextPos, nextPos);
        updatePromptLengthHint();
      }

      function loadPromptHistory() {
        try {
          const raw = localStorage.getItem(PROMPT_HISTORY_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          const seen = new Set();
          const out = [];
          parsed.forEach((entry) => {
            const value = String(entry || '').trim();
            if (!value) return;
            if (seen.has(value)) return;
            seen.add(value);
            out.push(value);
          });
          return out.slice(0, PROMPT_HISTORY_LIMIT);
        } catch (e) {
          return [];
        }
      }

      function persistPromptHistory() {
        localStorage.setItem(
          PROMPT_HISTORY_STORAGE_KEY,
          JSON.stringify(promptHistory.slice(0, PROMPT_HISTORY_LIMIT))
        );
      }

      function addPromptToHistory(prompt) {
        const value = String(prompt || '').trim();
        if (!value) return;
        promptHistory = [value, ...promptHistory.filter((item) => item !== value)].slice(0, PROMPT_HISTORY_LIMIT);
        persistPromptHistory();
        renderPromptHistory();
      }

      function removePromptFromHistory(index) {
        if (!Number.isInteger(index) || index < 0 || index >= promptHistory.length) return;
        promptHistory.splice(index, 1);
        persistPromptHistory();
        renderPromptHistory();
      }

      function renderPromptHelper() {
        const list = document.getElementById('promptHelperList');
        if (!list) return;
        if (!PROMPT_TEMPLATES.length) {
          list.innerHTML = `<div class="prompt-panel-empty">${escapeHtml(labels.prompt_helper_empty)}</div>`;
          return;
        }
        list.innerHTML = PROMPT_TEMPLATES.map((template) => (
          `<button class="prompt-list-item" type="button" data-template-id="${escapeHtml(template.id)}">` +
            `<strong>${escapeHtml(template.title)}</strong>` +
            `<span>${escapeHtml(template.text)}</span>` +
          `</button>`
        )).join('');
      }

      function renderPromptHistory() {
        const list = document.getElementById('promptHistoryList');
        if (!list) return;
        if (!promptHistory.length) {
          list.innerHTML = `<div class="prompt-panel-empty">${escapeHtml(labels.prompt_history_empty)}</div>`;
          return;
        }
        list.innerHTML = promptHistory.map((entry, index) => (
          `<div class="prompt-history-row">` +
            `<button class="prompt-list-item" type="button" data-history-index="${index}">` +
              `<span>${escapeHtml(entry)}</span>` +
            `</button>` +
            `<button class="prompt-history-remove" type="button" aria-label="${escapeHtml(labels.prompt_history_remove)}" data-history-remove="${index}">×</button>` +
          `</div>`
        )).join('');
      }

      function wirePromptListKeyboard(listEl) {
        if (!listEl) return;
        listEl.addEventListener('keydown', (event) => {
          const navKeys = ['ArrowDown', 'ArrowUp', 'Home', 'End'];
          if (!navKeys.includes(event.key)) return;
          const items = Array.from(listEl.querySelectorAll('button.prompt-list-item'));
          if (!items.length) return;
          const currentIndex = items.indexOf(document.activeElement);
          let nextIndex = currentIndex >= 0 ? currentIndex : 0;
          if (event.key === 'ArrowDown') nextIndex = (currentIndex + 1 + items.length) % items.length;
          if (event.key === 'ArrowUp') nextIndex = (currentIndex - 1 + items.length) % items.length;
          if (event.key === 'Home') nextIndex = 0;
          if (event.key === 'End') nextIndex = items.length - 1;
          event.preventDefault();
          items[nextIndex].focus();
        });
      }

      function loadFavorites() {
        try {
          const raw = localStorage.getItem(FAVORITES_STORAGE_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed
            .map((entry) => ({
              url: String(entry.url || '').trim(),
              prompt: String(entry.prompt || '').trim(),
              model: String(entry.model || '').trim(),
              ts: Number(entry.ts || 0) || Date.now(),
            }))
            .filter((entry) => !!entry.url)
            .slice(0, FAVORITES_MAX_ITEMS);
        } catch (e) {
          return [];
        }
      }

      function persistFavorites() {
        localStorage.setItem(
          FAVORITES_STORAGE_KEY,
          JSON.stringify(favorites.slice(0, FAVORITES_MAX_ITEMS))
        );
      }

      function isFavoriteUrl(url) {
        const key = String(url || '').trim();
        if (!key) return false;
        return favorites.some((entry) => entry.url === key);
      }

      function toggleFavorite(item) {
        if (!item || !item.url) return;
        const key = String(item.url).trim();
        if (!key) return;
        if (isFavoriteUrl(key)) {
          favorites = favorites.filter((entry) => entry.url !== key);
          persistFavorites();
          showToast(labels.result_favorite_removed);
          renderGallery();
          return;
        }
        favorites = [
          {
            url: key,
            prompt: String(item.prompt || '').trim(),
            model: String(item.model || ''),
            ts: Date.now(),
          },
          ...favorites.filter((entry) => entry.url !== key),
        ].slice(0, FAVORITES_MAX_ITEMS);
        persistFavorites();
        showToast(labels.result_favorite_saved);
        renderGallery();
      }

      function supportedReferenceModels() {
        return models.filter((model) => !!(model && (model.supportsReference || model.requiresReference)));
      }

      function closeEditWithAiModal() {
        editWithAiSourceItem = null;
        const modal = document.getElementById('editModelModal');
        if (!modal) return;
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
      }

      function renderEditWithAiModelList() {
        const list = document.getElementById('editModelList');
        if (!list) return;
        const available = supportedReferenceModels();
        if (!available.length) {
          list.innerHTML = `<div class="edit-model-empty">${escapeHtml(labels.result_edit_with_no_models)}</div>`;
          return;
        }
        list.innerHTML = available.map((model) => (
          `<button class="edit-model-btn" type="button" data-edit-model="${escapeHtml(model.key)}">${escapeHtml(model.display_name)}</button>`
        )).join('');
      }

      function openEditWithAiModal(item) {
        if (!item || !item.url) return;
        editWithAiSourceItem = item;
        renderEditWithAiModelList();
        const modal = document.getElementById('editModelModal');
        if (!modal) return;
        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
        const firstBtn = modal.querySelector('button.edit-model-btn');
        if (firstBtn) {
          setTimeout(() => firstBtn.focus(), 20);
        }
      }

      async function fetchReferenceFileFromResult(url) {
        const endpoint = `/api/download?url=${encodeURIComponent(url)}`;
        const res = await fetch(endpoint, { credentials: 'include' });
        if (!res.ok) {
          throw new Error(`download_${res.status}`);
        }
        const blob = await res.blob();
        const mime = String(blob.type || 'image/jpeg').toLowerCase();
        let ext = 'jpg';
        if (mime.includes('png')) ext = 'png';
        if (mime.includes('webp')) ext = 'webp';
        if (mime.includes('gif')) ext = 'gif';
        const name = `reference-${Date.now()}.${ext}`;
        return new File([blob], name, { type: blob.type || 'image/jpeg' });
      }

      async function applyEditWithAiModel(modelKey) {
        const item = editWithAiSourceItem;
        closeEditWithAiModal();
        if (!item || !item.url) return;
        const targetModel = models.find((model) => model.key === modelKey);
        if (!targetModel || !(targetModel.supportsReference || targetModel.requiresReference)) {
          showToast(labels.result_edit_with_no_models, 'warning');
          return;
        }
        selectModel(targetModel.key);
        if (!modelSupportsRefImages()) {
          showToast(labels.result_edit_with_no_models, 'warning');
          return;
        }
        let file;
        try {
          file = await fetchReferenceFileFromResult(item.url);
        } catch (err) {
          showToast(labels.result_reference_failed, 'error');
          const runStatus = document.getElementById('runStatus');
          if (runStatus) {
            runStatus.classList.add('error');
            runStatus.textContent = labels.result_reference_failed;
          }
          return;
        }
        const added = addReferenceFiles([file]);
        if (added < 1) {
          showToast(labels.result_reference_limit, 'warning');
          const runStatus = document.getElementById('runStatus');
          if (runStatus) {
            runStatus.classList.remove('error');
            runStatus.textContent = labels.result_reference_limit;
          }
          return;
        }
        window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
        const promptEl = getPromptInput();
        if (promptEl) {
          setTimeout(() => promptEl.focus(), 140);
        }
        showToast(labels.result_reference_added);
        const runStatus = document.getElementById('runStatus');
        if (runStatus) {
          runStatus.classList.remove('error');
          runStatus.textContent = labels.result_reference_added;
        }
      }

      function showToast(message, tone = '') {
        const toast = document.getElementById('uiToast');
        if (!toast) return;
        if (toastTimer) {
          clearTimeout(toastTimer);
          toastTimer = null;
        }
        toast.classList.remove('warning', 'error', 'visible');
        if (tone === 'warning' || tone === 'error') {
          toast.classList.add(tone);
        }
        toast.textContent = message || '';
        if (!message) return;
        toast.classList.add('visible');
        toastTimer = setTimeout(() => {
          toast.classList.remove('visible');
        }, 2500);
      }

      function setGenerationControlsLocked(locked) {
        document.querySelectorAll('.gen-lock-target').forEach((node) => {
          node.classList.toggle('locked', !!locked);
        });
        const promptEl = getPromptInput();
        if (promptEl) {
          promptEl.disabled = !!locked;
        }
        ['promptHelperBtn', 'promptHistoryBtn', 'refFiles', 'refReplaceFile'].forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;
          if ('disabled' in el) {
            el.disabled = !!locked;
          }
        });
      }

      function setGenerationLiveState({
        visible = false,
        text = '',
        eta = '',
        sub = '',
        tone = '',
        showSpinner = true,
        showCancel = false,
      }) {
        const wrap = document.getElementById('genLive');
        const textEl = document.getElementById('genLiveText');
        const etaEl = document.getElementById('genLiveEta');
        const subEl = document.getElementById('genLiveSub');
        const spinner = document.getElementById('genLiveSpinner');
        const cancelBtn = document.getElementById('genCancelBtn');
        if (!wrap || !textEl || !etaEl || !subEl || !spinner || !cancelBtn) return;

        wrap.classList.remove('error', 'warning');
        if (tone === 'error' || tone === 'warning') {
          wrap.classList.add(tone);
        }
        wrap.classList.toggle('visible', !!visible);
        textEl.textContent = text || '';
        etaEl.textContent = eta || '';
        subEl.textContent = sub || '';
        spinner.classList.toggle('hidden', !showSpinner);
        cancelBtn.classList.toggle('hidden', !showCancel);
      }

      function createGenerationWaitController() {
        const fakeStageDurations = [
          [1000, 3000],
          [3000, 6000],
          [5000, 10000],
          [2000, 6000],
        ];
        const etaProfiles = {
          default: {
            queued: [10, 30],
            generating: [10, 20],
            finalizing: [5, 10],
          },
          nano_banana: {
            queued: [8, 22],
            generating: [8, 18],
            finalizing: [4, 9],
          },
          nano_banana_pro: {
            queued: [15, 35],
            generating: [14, 28],
            finalizing: [7, 14],
          },
          nano_banana_edit: {
            queued: [12, 30],
            generating: [12, 24],
            finalizing: [6, 12],
          },
        };
        let active = false;
        let generationId = 0;
        let modelKey = '';
        let startedAt = 0;
        let fakeStage = 0;
        let fakeTimer = null;
        let pollTimer = null;
        let pollBackoffMs = GENERATION_STATUS_POLL_BASE_MS;
        let connectionIssue = false;
        let serverSnapshot = null;

        function randomBetween(min, max) {
          const a = Number(min || 0);
          const b = Number(max || a);
          return Math.floor(a + Math.random() * Math.max(1, b - a + 1));
        }

        function clearTimers() {
          if (fakeTimer) {
            clearTimeout(fakeTimer);
            fakeTimer = null;
          }
          if (pollTimer) {
            clearTimeout(pollTimer);
            pollTimer = null;
          }
        }

        function normalizeStatus(statusValue) {
          return String(statusValue || '').trim().toLowerCase();
        }

        function stageLabel(stageIndex) {
          if (stageIndex <= 0) return labels.gen_status_queued;
          if (stageIndex === 1) return labels.gen_status_step_1;
          if (stageIndex === 2) return labels.gen_status_step_2;
          return labels.gen_status_finalizing;
        }

        function etaRange(stageIndex) {
          const profile = etaProfiles[modelKey] || etaProfiles.default;
          if (stageIndex <= 0) return profile.queued;
          if (stageIndex >= 3) return profile.finalizing;
          return profile.generating;
        }

        function etaText(stageIndex) {
          const [minSec, maxSec] = etaRange(stageIndex);
          return fmt(labels.gen_eta_format, { min: minSec, max: maxSec });
        }

        function inferStageFromServer(snapshot) {
          if (!snapshot) return fakeStage;
          const status = normalizeStatus(snapshot.status);
          if (status === 'queued' || status === 'pending') {
            return 0;
          }
          if (status !== 'running') {
            return fakeStage;
          }
          const total = Number(snapshot.tasks_total || 0);
          if (total <= 0) {
            return fakeStage;
          }
          const success = Number(snapshot.tasks_success || 0);
          const fail = Number(snapshot.tasks_fail || 0);
          const running = Number(snapshot.tasks_running || 0);
          const progress = Math.max(0, Math.min(1, (success + fail + running * 0.6) / total));
          if (progress < 0.34) return 1;
          if (progress < 0.82) return 2;
          return 3;
        }

        function render() {
          if (!active) return;
          const stage = inferStageFromServer(serverSnapshot);
          let sub = '';
          let tone = '';
          if (connectionIssue) {
            sub = labels.gen_connection_retrying;
          }
          if (Date.now() - startedAt >= GENERATION_LONG_WAIT_MS) {
            sub = sub ? `${sub} ${labels.gen_taking_long}` : labels.gen_taking_long;
            tone = tone || 'warning';
          }
          setGenerationLiveState({
            visible: true,
            text: stageLabel(stage),
            eta: etaText(stage),
            sub,
            tone,
            showSpinner: true,
            showCancel: true,
          });
        }

        function scheduleFakeStage() {
          if (!active) return;
          if (fakeStage >= 3) return;
          const [minMs, maxMs] = fakeStageDurations[fakeStage] || [3000, 5000];
          fakeTimer = setTimeout(() => {
            if (!active) return;
            fakeStage = Math.min(3, fakeStage + 1);
            render();
            scheduleFakeStage();
          }, randomBetween(minMs, maxMs));
        }

        function schedulePoll(delayMs) {
          if (!active) return;
          if (pollTimer) {
            clearTimeout(pollTimer);
            pollTimer = null;
          }
          const jitter = randomBetween(-250, 250);
          const nextDelay = Math.max(600, Number(delayMs || GENERATION_STATUS_POLL_BASE_MS) + jitter);
          pollTimer = setTimeout(() => {
            void pollStatus();
          }, nextDelay);
        }

        async function pollStatus() {
          if (!active) return;
          if (!generationId) {
            schedulePoll(pollBackoffMs);
            return;
          }
          try {
            const res = await fetch(`/api/generations/${generationId}/status`, {
              credentials: 'include',
            });
            if (!res.ok) {
              throw new Error(`status_${res.status}`);
            }
            const data = await res.json();
            serverSnapshot = data || {};
            connectionIssue = false;
            pollBackoffMs = GENERATION_STATUS_POLL_BASE_MS;

            const status = normalizeStatus(data.status);
            if (status === 'success') {
              await finishSuccess(false);
              return;
            }
            if (status === 'partial') {
              await finishSuccess(true);
              return;
            }
            if (status === 'fail') {
              finishFail(data.error_message || labels.gen_failed_basic);
              return;
            }

            render();
            schedulePoll(pollBackoffMs);
          } catch (err) {
            connectionIssue = true;
            pollBackoffMs = Math.min(
              GENERATION_STATUS_POLL_MAX_MS,
              Math.floor(pollBackoffMs * 1.7)
            );
            render();
            schedulePoll(pollBackoffMs);
          }
        }

        async function finishSuccess(isPartial = false) {
          active = false;
          clearTimers();
          generationInFlight = false;
          resultSkeletonActive = false;
          pendingSkeletonCount = 0;
          renderGallery();
          setGenerationControlsLocked(false);
          setRunButtonState();
          setGenerationLiveState({
            visible: false,
            text: '',
            eta: '',
            sub: '',
            showSpinner: false,
            showCancel: false,
          });
          const runStatus = document.getElementById('runStatus');
          if (runStatus) {
            runStatus.classList.remove('error');
            runStatus.textContent = isPartial ? labels.gen_partial_done : labels.request_sent;
          }
          await loadMe();
          await loadHistory();
        }

        function finishFail(message) {
          active = false;
          clearTimers();
          generationInFlight = false;
          resultSkeletonActive = false;
          pendingSkeletonCount = 0;
          renderGallery();
          setGenerationControlsLocked(false);
          setRunButtonState();
          setGenerationLiveState({
            visible: true,
            text: labels.gen_failed_basic,
            eta: '',
            sub: message || '',
            tone: 'error',
            showSpinner: false,
            showCancel: false,
          });
          const runStatus = document.getElementById('runStatus');
          if (runStatus) {
            runStatus.classList.add('error');
            runStatus.textContent = `${labels.error_prefix}: ${message || labels.gen_failed_basic}`;
          }
        }

        function callBackendCancel() {
          // Backend cancel endpoint is not implemented yet.
          // Local cancel stops UI waiting state and polling only.
        }

        function cancelLocally() {
          if (!active) return false;
          active = false;
          clearTimers();
          generationInFlight = false;
          resultSkeletonActive = false;
          pendingSkeletonCount = 0;
          renderGallery();
          setGenerationControlsLocked(false);
          setRunButtonState();
          callBackendCancel();
          setGenerationLiveState({
            visible: true,
            text: labels.gen_canceled_local,
            eta: '',
            sub: '',
            tone: 'warning',
            showSpinner: false,
            showCancel: false,
          });
          const runStatus = document.getElementById('runStatus');
          if (runStatus) {
            runStatus.classList.remove('error');
            runStatus.textContent = labels.gen_canceled_local;
          }
          return true;
        }

        function stopAndHide() {
          active = false;
          clearTimers();
          generationInFlight = false;
          resultSkeletonActive = false;
          pendingSkeletonCount = 0;
          renderGallery();
          setGenerationControlsLocked(false);
          setRunButtonState();
          setGenerationLiveState({
            visible: false,
            text: '',
            eta: '',
            sub: '',
            showSpinner: false,
            showCancel: false,
          });
        }

        function start(nextGenerationId, nextModelKey, nextOutputs = 1) {
          stopAndHide();
          generationId = Number(nextGenerationId || 0);
          modelKey = String(nextModelKey || '').trim();
          pendingSkeletonCount = Math.max(1, Number(nextOutputs || 1));
          resultSkeletonActive = true;
          startedAt = Date.now();
          fakeStage = 0;
          pollBackoffMs = GENERATION_STATUS_POLL_BASE_MS;
          connectionIssue = false;
          serverSnapshot = null;
          active = true;
          generationInFlight = true;
          renderGallery();
          setGenerationControlsLocked(true);
          setRunButtonState();
          render();
          scheduleFakeStage();
          schedulePoll(900);
        }

        return {
          start,
          cancelLocally,
          isActive: () => active,
          stopAndHide,
        };
      }

      const generationWaitController = createGenerationWaitController();

      function setBalance(balance) {
        currentBalance = Number.isFinite(Number(balance)) ? Number(balance) : 0;
        const label = `${labels.balance}: ${balance} ${labels.credits}`;
        document.getElementById('balanceLabel').textContent = label;
      }

      function hasEnoughCredits() {
        if (!quoteData || !Number.isFinite(Number(quoteData.total))) return true;
        return currentBalance >= Number(quoteData.total);
      }

      function getSkipConfirmSetting() {
        const raw = localStorage.getItem(SKIP_CONFIRM_STORAGE_KEY);
        return raw === '1';
      }

      function setSkipConfirmSetting(enabled) {
        localStorage.setItem(SKIP_CONFIRM_STORAGE_KEY, enabled ? '1' : '0');
      }

      function isNewUserMandatoryConfirm() {
        return generationCount < NEW_USER_CONFIRM_REQUIRED_COUNT;
      }

      function isConfirmRequiredForCurrentUser() {
        if (isNewUserMandatoryConfirm()) return true;
        return !getSkipConfirmSetting();
      }

      function setRunButtonState() {
        const runBtn = document.getElementById('runBtn');
        if (!runBtn) return;
        runBtn.disabled = runInProgress || confirmModalOpen || generationInFlight;
      }

      function labelForBreakdownKey(key) {
        const value = String(key || '').toLowerCase();
        if (!value) return '';
        if (value.startsWith('aspect_')) {
          const ratioKey = `ratio_${value.slice('aspect_'.length)}`;
          const ratioLabel = labels[ratioKey] || value.slice('aspect_'.length).replaceAll('_', ':');
          return `${labels.aspect_ratio}: ${ratioLabel}`;
        }
        if (value.startsWith('resolution_')) {
          const resKey = `res_${value.slice('resolution_'.length).toLowerCase()}`;
          const resLabel = labels[resKey] || value.slice('resolution_'.length).toUpperCase();
          return `${labels.resolution}: ${resLabel}`;
        }
        if (value.startsWith('output_format_')) {
          return `${labels.output_format}: ${value.slice('output_format_'.length).toUpperCase()}`;
        }
        if (value.startsWith('ref_')) {
          return labels.upload_label || 'References';
        }
        if (value.startsWith('bundle_')) {
          return value.replaceAll('_', ' ');
        }
        return value.replaceAll('_', ' ');
      }

      function closeQuoteTooltip() {
        const tooltip = document.getElementById('quoteTooltip');
        const btn = document.getElementById('quoteInfoBtn');
        if (!tooltip || !btn) return;
        quoteTooltipOpen = false;
        tooltip.classList.remove('open');
        tooltip.setAttribute('aria-hidden', 'true');
        btn.setAttribute('aria-expanded', 'false');
      }

      function openQuoteTooltip() {
        const tooltip = document.getElementById('quoteTooltip');
        const btn = document.getElementById('quoteInfoBtn');
        if (!tooltip || !btn) return;
        if (!quoteData || !quoteData.breakdown) return;
        quoteTooltipOpen = true;
        tooltip.classList.add('open');
        tooltip.setAttribute('aria-hidden', 'false');
        btn.setAttribute('aria-expanded', 'true');
      }

      function toggleQuoteTooltip() {
        if (quoteTooltipOpen) {
          closeQuoteTooltip();
        } else {
          openQuoteTooltip();
        }
      }

      function renderQuote() {
        const costText = document.getElementById('quoteCostText');
        const infoBtn = document.getElementById('quoteInfoBtn');
        const tooltip = document.getElementById('quoteTooltip');
        if (!costText || !infoBtn || !tooltip) return;

        if (!currentModel) {
          costText.textContent = '';
          infoBtn.style.display = 'none';
          closeQuoteTooltip();
          return;
        }
        if (!loggedIn) {
          costText.textContent = labels.quote_login_required;
          infoBtn.style.display = 'none';
          closeQuoteTooltip();
          return;
        }
        if (!quoteData || !Number.isFinite(Number(quoteData.total))) {
          costText.textContent = labels.quote_unavailable;
          infoBtn.style.display = 'none';
          closeQuoteTooltip();
          return;
        }

        const total = Number(quoteData.total);
        costText.textContent = fmt(labels.quote_cost, { total });
        infoBtn.style.display = 'inline-flex';

        const breakdown = quoteData.breakdown || {};
        const rows = [];
        rows.push({
          label: labels.quote_breakdown_base,
          amount: Number(breakdown.base || 0),
        });
        const modifiers = Array.isArray(breakdown.modifiers) ? breakdown.modifiers : [];
        modifiers.forEach((item) => {
          const amount = Number(item.amount || 0);
          if (!Number.isFinite(amount) || amount === 0) return;
          rows.push({
            label: labelForBreakdownKey(item.key),
            amount,
          });
        });
        const outputs = Number(breakdown.outputs || 1);
        const outputsExtra = Number(breakdown.outputs_extra || 0);
        if (outputs > 1) {
          rows.push({
            label: fmt(labels.quote_breakdown_outputs, { count: outputs }),
            amount: outputsExtra,
          });
        }
        const discountPct = Number(quoteData.discount_pct || 0);
        if (discountPct > 0) {
          const subtotal = Number(breakdown.subtotal || 0);
          const discountValue = Math.max(0, subtotal - total);
          rows.push({
            label: `${labels.quote_breakdown_discount} (${discountPct}%)`,
            amount: -discountValue,
          });
        }
        rows.push({
          label: labels.quote_breakdown_total,
          amount: total,
          total: true,
        });

        const html = [];
        html.push(`<div class="quote-tooltip-title">${labels.quote_info_title}</div>`);
        if (rows.length <= 1) {
          html.push(`<div class="quote-tooltip-row">${labels.quote_breakdown_fallback}</div>`);
        } else {
          rows.forEach((row) => {
            const sign = row.amount > 0 && !row.total ? '+' : '';
            const rowClass = row.total ? 'quote-tooltip-row total' : 'quote-tooltip-row';
            html.push(
              `<div class="${rowClass}"><span>${row.label}</span><span>${sign}${row.amount}</span></div>`
            );
          });
        }
        tooltip.innerHTML = html.join('');
      }

      function openConfirmModal(costValue) {
        const modal = document.getElementById('confirmModal');
        const textEl = document.getElementById('confirmText');
        const okBtn = document.getElementById('confirmOkBtn');
        const dontShowCheckbox = document.getElementById('confirmDontShowCheckbox');
        const dontShowWrap = document.getElementById('confirmDontShowWrap');
        if (!modal || !textEl) return;
        const mandatory = isNewUserMandatoryConfirm();
        textEl.textContent = fmt(labels.confirm_message, { total: costValue });
        if (dontShowCheckbox) {
          dontShowCheckbox.checked = getSkipConfirmSetting();
          dontShowCheckbox.disabled = mandatory;
        }
        if (dontShowWrap) {
          dontShowWrap.classList.toggle('disabled', mandatory);
        }
        modal.classList.add('open');
        modal.setAttribute('aria-hidden', 'false');
        confirmModalOpen = true;
        setRunButtonState();
        if (okBtn) {
          setTimeout(() => okBtn.focus(), 20);
        }
      }

      function closeConfirmModal() {
        const modal = document.getElementById('confirmModal');
        if (!modal) return;
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
        confirmModalOpen = false;
        setRunButtonState();
      }

      function updateSkipConfirmToggleUi() {
        const toggle = document.getElementById('skipConfirmToggle');
        if (!toggle) return;
        const mandatory = isNewUserMandatoryConfirm();
        toggle.checked = getSkipConfirmSetting();
        toggle.disabled = mandatory;
        const wrapper = toggle.closest('.user-setting');
        if (wrapper) {
          wrapper.classList.toggle('disabled', mandatory);
        }
      }

      function setUserInfo(me) {
        const name = me.display_name || me.username || `ID ${me.telegram_id}`;
        const nameEl = document.getElementById('userName');
        if (nameEl) nameEl.textContent = name;
        const avatarEl = document.getElementById('userAvatar');
        if (!avatarEl) return;
        if (me.photo_url) {
          avatarEl.style.backgroundImage = `url('${me.photo_url}')`;
          avatarEl.textContent = '';
        } else {
          avatarEl.style.backgroundImage = '';
          avatarEl.textContent = name.charAt(0).toUpperCase();
        }
      }

      function updateRefHint() {
        const refTitle = document.getElementById('refTitle');
        const refSub = document.getElementById('refSub');
        const refNote = document.getElementById('refNote');
        if (!currentModel) return;
        const max = currentModel.max_reference_images || 0;
        const count = selectedFiles.length;
        refTitle.textContent = fmt(labels.ref_images_title, { count, max });
        if (currentModel.requires_reference_images) {
          refSub.textContent = fmt(labels.upload_hint_required, { max });
        } else if (currentModel.supports_reference_images) {
          refSub.textContent = fmt(labels.upload_hint_optional, { max });
        } else {
          refSub.textContent = '';
        }
        refNote.textContent = fmt(labels.ref_images_note, { max });
      }

      async function loadMe() {
        const res = await fetch('/api/me');
        if (!res.ok) return;
        const data = await res.json();
        setBalance(data.balance);
        setUserInfo(data);
        maxOutputs = data.max_outputs || 1;
        generationCount = Number(data.generation_count || 0);
        updateSkipConfirmToggleUi();
        renderQuote();
      }

      function setCryptoStatus(message, state = '') {
        const status = document.getElementById('cryptoStatus');
        if (!status) return;
        status.textContent = message || '';
        status.classList.remove('error', 'success');
        if (state === 'error') {
          status.classList.add('error');
        }
        if (state === 'success') {
          status.classList.add('success');
        }
      }

      function setPromoStatus(message, state = '') {
        const status = document.getElementById('promoStatus');
        if (!status) return;
        status.textContent = message || '';
        status.classList.remove('error', 'success');
        if (state === 'error') {
          status.classList.add('error');
        }
        if (state === 'success') {
          status.classList.add('success');
        }
      }

      function formatMoney(value) {
        const number = Number(value);
        if (!Number.isFinite(number)) return '0.00';
        return number.toFixed(2);
      }

      function toFiniteNumber(value, fallback = 0) {
        const number = Number(value);
        return Number.isFinite(number) ? number : fallback;
      }

      function getCryptoPackageCredits(item) {
        return Math.max(0, Math.round(toFiniteNumber(item.credits_amount, 0)));
      }

      function getCryptoPackageCents(item) {
        return Math.max(0, Math.round(toFiniteNumber(item.amount, 0) * 100));
      }

      function getCryptoPackageRate(item) {
        const credits = getCryptoPackageCredits(item);
        if (credits <= 0) return 0;
        const rawRate = getCryptoPackageCents(item) / credits;
        return Math.round(rawRate * 1000) / 1000;
      }

      function compareCryptoRates(a, b) {
        const rateA = getCryptoPackageRate(a);
        const rateB = getCryptoPackageRate(b);
        if (rateA <= 0 && rateB <= 0) return 0;
        if (rateA <= 0) return 1;
        if (rateB <= 0) return -1;
        if (rateA < rateB) return -1;
        if (rateA > rateB) return 1;
        return 0;
      }

      function pickBetterCryptoPackage(a, b) {
        if (!a) return b;
        if (!b) return a;
        const rateCmp = compareCryptoRates(a, b);
        if (rateCmp < 0) return a;
        if (rateCmp > 0) return b;
        const creditsA = getCryptoPackageCredits(a);
        const creditsB = getCryptoPackageCredits(b);
        if (creditsA > creditsB) return a;
        if (creditsA < creditsB) return b;
        const sortA = toFiniteNumber(a.sort_order, 0);
        const sortB = toFiniteNumber(b.sort_order, 0);
        if (sortA < sortB) return a;
        if (sortA > sortB) return b;
        const idA = Number(a.id || 0);
        const idB = Number(b.id || 0);
        return idA <= idB ? a : b;
      }

      function getCryptoBaselineRate() {
        if (!cryptoPackages.length) return 0;
        let worst = null;
        cryptoPackages.forEach((item) => {
          if (getCryptoPackageCredits(item) <= 0) return;
          if (!worst || compareCryptoRates(item, worst) > 0) {
            worst = item;
          }
        });
        if (!worst) return 0;
        return getCryptoPackageRate(worst);
      }

      function getCryptoBestValueId() {
        if (!cryptoPackages.length) return 0;
        let best = null;
        cryptoPackages.forEach((item) => {
          if (getCryptoPackageCredits(item) <= 0) return;
          best = pickBetterCryptoPackage(best, item);
        });
        return Number(best?.id || 0);
      }

      function renderCryptoPackageCards() {
        const list = document.getElementById('cryptoPackageList');
        const select = document.getElementById('cryptoPackage');
        if (!list || !select) return;
        list.innerHTML = '';
        if (!cryptoPackages.length) return;

        const selectedId = Number(select.value || cryptoPackages[0].id || 0);
        const baselineRate = getCryptoBaselineRate();
        const bestValueId = getCryptoBestValueId();

        cryptoPackages.forEach((item) => {
          const card = document.createElement('button');
          card.type = 'button';
          card.className = 'crypto-package-card' + (Number(item.id) === selectedId ? ' active' : '');

          const title = document.createElement('div');
          title.className = 'crypto-package-title';
          title.textContent = String(item.title || '');

          const badges = document.createElement('div');
          badges.className = 'crypto-package-badges';
          if (Number(item.id || 0) === bestValueId) {
            const best = document.createElement('span');
            best.className = 'crypto-badge best';
            best.textContent = labels.crypto_best_value;
            badges.appendChild(best);
          }

          const bonus = toFiniteNumber(item.credits_bonus, 0);
          if (bonus > 0) {
            const bonusBadge = document.createElement('span');
            bonusBadge.className = 'crypto-badge';
            bonusBadge.textContent = fmt(labels.crypto_bonus_badge, { bonus });
            badges.appendChild(bonusBadge);
          }

          const rate = getCryptoPackageRate(item);
          if (baselineRate > 0 && rate > 0 && rate < baselineRate) {
            const savePct = Math.round(((baselineRate - rate) / baselineRate) * 100);
            if (savePct > 0) {
              const saveBadge = document.createElement('span');
              saveBadge.className = 'crypto-badge save';
              saveBadge.textContent = fmt(labels.crypto_save_badge, { pct: savePct });
              badges.appendChild(saveBadge);
            }
          }

          const credits = toFiniteNumber(item.credits_amount, 0);
          const totalLine = document.createElement('div');
          totalLine.className = 'crypto-package-line';
          totalLine.textContent = fmt(labels.crypto_total_line, { credits });

          const base = toFiniteNumber(item.credits_base, credits);
          let baseBonusLine = null;
          if (bonus > 0) {
            baseBonusLine = document.createElement('div');
            baseBonusLine.className = 'crypto-package-line';
            baseBonusLine.textContent = fmt(labels.crypto_base_bonus_line, { base, bonus });
          }

          const price = document.createElement('div');
          price.className = 'crypto-package-price';
          price.textContent = `${formatMoney(item.amount)} ${item.currency || ''}`.trim();

          const head = document.createElement('div');
          head.className = 'crypto-package-head';
          head.appendChild(title);

          card.appendChild(head);
          if (badges.childNodes.length) {
            card.appendChild(badges);
          }
          if (baseBonusLine) {
            card.appendChild(baseBonusLine);
          }
          card.appendChild(totalLine);
          card.appendChild(price);

          card.addEventListener('click', () => {
            select.value = String(item.id);
            renderCryptoPackageCards();
          });

          list.appendChild(card);
        });
      }

      function stopCryptoPolling() {
        if (cryptoPollTimer) {
          clearInterval(cryptoPollTimer);
          cryptoPollTimer = null;
        }
        cryptoPollBusy = false;
        cryptoPollAttempts = 0;
      }

      function fillCryptoPackages() {
        const select = document.getElementById('cryptoPackage');
        if (!select) return;
        const previousValue = select.value;
        select.innerHTML = '';
        if (!cryptoPackages.length) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = labels.crypto_packages_empty;
          select.appendChild(option);
          select.disabled = true;
          const createBtn = document.getElementById('cryptoCreateBtn');
          if (createBtn) createBtn.disabled = true;
          renderCryptoPackageCards();
          return;
        }
        select.disabled = false;
        const createBtn = document.getElementById('cryptoCreateBtn');
        if (createBtn) createBtn.disabled = false;
        cryptoPackages.forEach((item) => {
          const option = document.createElement('option');
          option.value = String(item.id);
          option.textContent = `${item.title} - ${item.credits_amount} ${labels.credits}`;
          select.appendChild(option);
        });
        if (previousValue && cryptoPackages.some((item) => String(item.id) === previousValue)) {
          select.value = previousValue;
        } else {
          select.value = String(cryptoPackages[0].id);
        }
        renderCryptoPackageCards();
      }

      async function loadCryptoPackages() {
        const payLink = document.getElementById('cryptoPayLink');
        const checkBtn = document.getElementById('cryptoCheckBtn');
        if (!payLink || !checkBtn) return;
        if (!loggedIn) {
          cryptoPackages = [];
          fillCryptoPackages();
          payLink.style.display = 'none';
          checkBtn.disabled = true;
          setCryptoStatus(labels.login_required, 'error');
          return;
        }
        setCryptoStatus(labels.crypto_loading_packages);
        const res = await fetch('/api/payments/packages', { credentials: 'include' });
        if (!res.ok) {
          cryptoPackages = [];
          fillCryptoPackages();
          payLink.style.display = 'none';
          checkBtn.disabled = true;
          setCryptoStatus(labels.crypto_unavailable, 'error');
          return;
        }
        const data = await res.json();
        if (!data.enabled) {
          cryptoPackages = [];
          fillCryptoPackages();
          payLink.style.display = 'none';
          checkBtn.disabled = true;
          setCryptoStatus(labels.crypto_unavailable, 'error');
          return;
        }
        cryptoPackages = Array.isArray(data.packages) ? data.packages : [];
        fillCryptoPackages();
        if (!cryptoPackages.length) {
          payLink.style.display = 'none';
          checkBtn.disabled = true;
          setCryptoStatus(labels.crypto_packages_empty);
          return;
        }
        setCryptoStatus('');
      }

      async function loadModels() {
        const res = await fetch('/api/models');
        if (!res.ok) return;
        const data = await res.json();
        const incoming = Array.isArray(data.models) ? data.models : [];
        models = incoming.map((model) => ({
          ...model,
          supportsReference: !!(model.supportsReference || model.supports_reference_images),
          requiresReference: !!(model.requiresReference || model.requires_reference_images),
          supports_reference_images: !!(model.supportsReference || model.supports_reference_images),
          requires_reference_images: !!(model.requiresReference || model.requires_reference_images),
        }));
        modelNames = {};
        models.forEach((m) => { modelNames[m.key] = m.display_name; });
        renderModels();
      }

      function renderModels() {
        const container = document.getElementById('modelButtons');
        container.innerHTML = '';
        models.forEach((m) => {
          const btn = document.createElement('button');
          btn.className = 'model-btn' + (currentModel && currentModel.key === m.key ? ' active' : '');
          btn.textContent = m.display_name;
          btn.onclick = () => selectModel(m.key);
          container.appendChild(btn);
        });
        if (!currentModel && models.length) selectModel(models[0].key);
      }

      function selectModel(key) {
        const nextModel = models.find((m) => m.key === key);
        if (!nextModel) return;
        const modelChanged = !currentModel || currentModel.key !== nextModel.key;
        currentModel = nextModel;
        document.getElementById('modelTagline').textContent = currentModel.tagline || '';
        document.getElementById('uploadBlock').style.display =
          (currentModel.supports_reference_images || currentModel.requires_reference_images) ? 'block' : 'none';
        if (modelChanged) {
          optionsState = {};
          currentModel.options.forEach((opt) => optionsState[opt.key] = opt.default);
          optionsState.outputs = 1;
          resetRefSelection();
        } else {
          if (!optionsState.outputs) {
            optionsState.outputs = 1;
          }
          renderRefGrid();
        }
        renderModels();
        renderOptions();
      }

      function optionIcon(key) {
        const map = {
          output_format: '🖼️',
          image_size: '📐',
          aspect_ratio: '📐',
          resolution: '🧩',
        };
        return map[key] || '⚙️';
      }

      function renderOptions() {
        const container = document.getElementById('optionsContainer');
        container.innerHTML = '';
        currentModel.options.forEach((opt) => {
          const group = document.createElement('div');
          group.className = 'options-group';
          const title = document.createElement('div');
          title.className = 'option-title';
          title.textContent = `${optionIcon(opt.key)} ${opt.label}`;
          group.appendChild(title);

          const buttons = document.createElement('div');
          buttons.className = 'option-buttons';
          opt.values.forEach((v) => {
            const btn = document.createElement('button');
            btn.className = 'option-btn' + (optionsState[opt.key] === v.value ? ' active' : '');
            btn.textContent = v.label;
            btn.onclick = () => {
              optionsState[opt.key] = v.value;
              renderOptions();
              updateQuote();
            };
            buttons.appendChild(btn);
          });
          group.appendChild(buttons);
          container.appendChild(group);
        });

        const outputsGroup = document.createElement('div');
        outputsGroup.className = 'options-group';
        const outputsTitle = document.createElement('div');
        outputsTitle.className = 'option-title';
        outputsTitle.textContent = `🔢 ${labels.outputs}`;
        outputsGroup.appendChild(outputsTitle);
        const outputsButtons = document.createElement('div');
        outputsButtons.className = 'option-buttons';
        for (let i = 1; i <= maxOutputs; i++) {
          const btn = document.createElement('button');
          btn.className = 'option-btn' + (optionsState.outputs === i ? ' active' : '');
          btn.textContent = i;
          btn.onclick = () => {
            optionsState.outputs = i;
            renderOptions();
            updateQuote();
          };
          outputsButtons.appendChild(btn);
        }
        outputsGroup.appendChild(outputsButtons);
        container.appendChild(outputsGroup);
      }

      function firstValidIndex(start = 0) {
        if (!galleryItems.length) return -1;
        for (let i = 0; i < galleryItems.length; i++) {
          const idx = (start + i) % galleryItems.length;
          if (!galleryItems[idx].invalid) return idx;
        }
        return -1;
      }

      function setGalleryMode(mode) {
        const nextMode = mode === 'grid' ? 'grid' : 'carousel';
        galleryMode = nextMode;
        const carouselBtn = document.getElementById('viewCarouselBtn');
        const gridBtn = document.getElementById('viewGridBtn');
        if (carouselBtn) {
          carouselBtn.classList.toggle('active', galleryMode === 'carousel');
        }
        if (gridBtn) {
          gridBtn.classList.toggle('active', galleryMode === 'grid');
        }
        renderGallery();
      }

      function renderOutputViewToggle(show) {
        const wrap = document.getElementById('outputViewToggle');
        if (!wrap) return;
        wrap.style.display = show ? 'inline-flex' : 'none';
        const carouselBtn = document.getElementById('viewCarouselBtn');
        const gridBtn = document.getElementById('viewGridBtn');
        if (carouselBtn) {
          carouselBtn.classList.toggle('active', galleryMode === 'carousel');
        }
        if (gridBtn) {
          gridBtn.classList.toggle('active', galleryMode === 'grid');
        }
      }

      function getValidGalleryItems() {
        return galleryItems.filter((item) => !item.invalid);
      }

      function renderGallerySkeleton() {
        const gallery = document.getElementById('gallery');
        const grid = document.getElementById('galleryGrid');
        const actions = document.getElementById('galleryActions');
        const thumbsWrap = document.getElementById('thumbsWrap');
        const pages = document.getElementById('thumbsPages');
        if (!gallery || !grid || !actions || !thumbsWrap || !pages) return;
        const count = Math.max(1, Number(pendingSkeletonCount || 1));
        const cardsHtml = Array.from({ length: count }).map(() => (
          `<div class="result-skeleton">` +
            `<div class="result-skeleton-img"></div>` +
            `<div class="result-skeleton-line"></div>` +
            `<div class="result-skeleton-line short"></div>` +
          `</div>`
        )).join('');
        grid.innerHTML = cardsHtml;
        grid.style.display = 'grid';
        gallery.style.display = 'none';
        actions.style.display = 'none';
        thumbsWrap.style.display = 'none';
        pages.style.display = 'none';
        renderOutputViewToggle(count > 1);
      }

      function applyResultPrompt(item) {
        if (!item || !item.prompt) return;
        const promptEl = getPromptInput();
        if (!promptEl) return;
        promptEl.value = item.prompt;
        updatePromptLengthHint();
        window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
        setTimeout(() => promptEl.focus(), 120);
      }

      async function regenerateFromResult(forceSingleOutput = false) {
        if (forceSingleOutput) {
          optionsState.outputs = 1;
          renderOptions();
          updateQuote();
        }
        await runGenerationFlow();
      }

      async function deleteResultItem(item) {
        if (!item || !item.generation_id) return;
        const generationId = Number(item.generation_id || 0);
        if (!generationId) return;
        const res = await fetch(`/api/generations/${generationId}/delete`, {
          method: 'POST',
          credentials: 'include',
        });
        if (!res.ok) {
          alert(`${labels.error_prefix}: ${labels.delete_failed || 'delete_failed'}`);
          return;
        }
        galleryItems = galleryItems.filter((x) => Number(x.generation_id || 0) !== generationId);
        renderGallery();
      }

      function renderGalleryCardActions(item, compact = false) {
        const fragment = document.createDocumentFragment();
        const addAction = (element) => {
          if (compact) {
            element.classList.add('compact');
          }
          fragment.appendChild(element);
        };

        const download = document.createElement('a');
        download.className = 'action-btn';
        download.href = `/api/download?url=${encodeURIComponent(item.url)}`;
        download.setAttribute('download', '');
        download.textContent = `⬇ ${labels.result_download}`;
        addAction(download);

        const regenerateBtn = document.createElement('button');
        regenerateBtn.className = 'action-btn';
        regenerateBtn.type = 'button';
        regenerateBtn.textContent = `🔁 ${compact ? labels.result_regenerate_this : labels.result_regenerate}`;
        regenerateBtn.onclick = () => {
          void regenerateFromResult(compact);
        };
        addAction(regenerateBtn);

        const editPromptBtn = document.createElement('button');
        editPromptBtn.className = 'action-btn';
        editPromptBtn.type = 'button';
        editPromptBtn.textContent = `✏ ${labels.result_edit_prompt}`;
        editPromptBtn.onclick = () => applyResultPrompt(item);
        addAction(editPromptBtn);

        const editAiBtn = document.createElement('button');
        editAiBtn.className = 'action-btn';
        editAiBtn.type = 'button';
        editAiBtn.textContent = `🧩 ${labels.result_edit_ai}`;
        editAiBtn.onclick = () => openEditWithAiModal(item);
        addAction(editAiBtn);

        const favoriteBtn = document.createElement('button');
        favoriteBtn.className = 'action-btn';
        favoriteBtn.type = 'button';
        const favored = isFavoriteUrl(item.url);
        favoriteBtn.classList.toggle('favorited', favored);
        favoriteBtn.textContent = `⭐ ${favored ? labels.result_favorite_remove : labels.result_favorite_add}`;
        favoriteBtn.onclick = () => toggleFavorite(item);
        addAction(favoriteBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'action-btn';
        deleteBtn.type = 'button';
        deleteBtn.textContent = `🗑 ${labels.delete}`;
        deleteBtn.onclick = () => {
          void deleteResultItem(item);
        };
        addAction(deleteBtn);

        return fragment;
      }

      function renderGallery() {
        const gallery = document.getElementById('gallery');
        const grid = document.getElementById('galleryGrid');
        const actions = document.getElementById('galleryActions');
        const thumbsWrap = document.getElementById('thumbsWrap');
        const pages = document.getElementById('thumbsPages');
        if (!gallery || !grid || !actions || !thumbsWrap || !pages) return;

        if (resultSkeletonActive) {
          renderGallerySkeleton();
          return;
        }

        gallery.innerHTML = '';
        grid.innerHTML = '';
        const validItems = getValidGalleryItems();
        renderOutputViewToggle(validItems.length > 1);

        const validIndex = firstValidIndex(galleryIndex);
        if (validIndex === -1) {
          gallery.style.display = 'block';
          grid.style.display = 'none';
          actions.style.display = 'none';
          thumbsWrap.style.display = 'none';
          pages.style.display = 'none';
          gallery.innerHTML = `<div class="gallery-empty">${labels.output_empty_hint || labels.output_empty}</div>`;
          return;
        }
        galleryIndex = validIndex;
        const item = galleryItems[galleryIndex];

        if (galleryMode === 'grid' && validItems.length > 1) {
          gallery.style.display = 'none';
          grid.style.display = 'grid';
          actions.style.display = 'none';
          thumbsWrap.style.display = 'none';
          pages.style.display = 'none';
          validItems.forEach((cardItem) => {
            const card = document.createElement('div');
            card.className = 'gallery-card';
            if (cardItem.url === item.url) {
              card.classList.add('active');
            }
            const main = document.createElement('div');
            main.className = 'gallery-card-main';
            const img = document.createElement('img');
            img.src = cardItem.url;
            img.onerror = () => {
              cardItem.invalid = true;
              renderGallery();
            };
            main.appendChild(img);
            main.onclick = () => {
              galleryIndex = galleryItems.indexOf(cardItem);
              renderGallery();
            };
            card.appendChild(main);

            const meta = document.createElement('div');
            meta.className = 'gallery-card-meta';
            meta.textContent = modelNames[cardItem.model] || cardItem.model;
            card.appendChild(meta);

            const cardActions = document.createElement('div');
            cardActions.className = 'gallery-card-actions';
            cardActions.appendChild(renderGalleryCardActions(cardItem, true));
            card.appendChild(cardActions);
            grid.appendChild(card);
          });
          return;
        }

        gallery.style.display = 'block';
        grid.style.display = 'none';

        const img = document.createElement('img');
        img.src = item.url;
        img.onerror = () => {
          item.invalid = true;
          renderGallery();
        };
        gallery.appendChild(img);

        const badge = document.createElement('div');
        badge.className = 'gallery-badge';
        badge.textContent = modelNames[item.model] || item.model;
        gallery.appendChild(badge);

        const count = document.createElement('div');
        count.className = 'gallery-count';
        count.textContent = `${validItems.findIndex((x) => x.url === item.url) + 1} / ${validItems.length}`;
        gallery.appendChild(count);

        if (validItems.length > 1) {
          const prev = document.createElement('div');
          prev.className = 'gallery-nav prev';
          prev.textContent = '‹';
          prev.onclick = () => {
            galleryIndex = (galleryIndex - 1 + galleryItems.length) % galleryItems.length;
            renderGallery();
          };
          gallery.appendChild(prev);

          const next = document.createElement('div');
          next.className = 'gallery-nav next';
          next.textContent = '›';
          next.onclick = () => {
            galleryIndex = (galleryIndex + 1) % galleryItems.length;
            renderGallery();
          };
          gallery.appendChild(next);
        }

        actions.innerHTML = '';
        actions.appendChild(renderGalleryCardActions(item, false));
        actions.style.display = 'flex';
        thumbsWrap.style.display = validItems.length > 1 ? 'block' : 'none';
        pages.style.display = 'none';
        renderThumbs(item, true);
      }

      function thumbColumns() {
        const thumbs = document.getElementById('thumbs');
        const fixedDesktopCols = 8;
        if (window.innerWidth >= 1100) {
          return fixedDesktopCols;
        }
        const minThumb = 56;
        const gap = 8;
        const width = thumbs.clientWidth || thumbs.offsetWidth || 0;
        return Math.max(1, Math.floor((width + gap) / (minThumb + gap)));
      }

      function snakeRows(items, cols) {
        const out = [];
        for (let i = 0; i < items.length; i += cols) {
          const rowIndex = Math.floor(i / cols);
          const row = items.slice(i, i + cols);
          if (rowIndex % 2 === 1) {
            row.reverse();
          }
          out.push(...row);
        }
        return out;
      }

      function renderThumbs(currentItem, focusCurrent) {
        const thumbs = document.getElementById('thumbs');
        const prevBtn = document.getElementById('thumbsPrev');
        const nextBtn = document.getElementById('thumbsNext');
        const pages = document.getElementById('thumbsPages');
        thumbs.innerHTML = '';

        const thumbItems = galleryItems.filter((x) => !x.invalid);
        if (!thumbItems.length) {
          prevBtn.style.display = 'none';
          nextBtn.style.display = 'none';
          pages.style.display = 'none';
          return;
        }

        const cols = thumbColumns();
        thumbs.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
        const pageSize = Math.max(1, cols * THUMB_ROWS);
        const totalPages = Math.max(1, Math.ceil(thumbItems.length / pageSize));
        const currentIdx = currentItem ? thumbItems.findIndex((x) => x.url === currentItem.url) : -1;

        if (focusCurrent && currentIdx >= 0) {
          thumbsPage = Math.floor(currentIdx / pageSize);
        }
        if (thumbsPage >= totalPages) thumbsPage = totalPages - 1;
        if (thumbsPage < 0) thumbsPage = 0;

        const start = thumbsPage * pageSize;
        const pageItems = thumbItems.slice(start, start + pageSize);
        const displayItems = snakeRows(pageItems, cols);

        displayItems.forEach((thumbItem) => {
          const wrap = document.createElement('div');
          wrap.className = 'thumb' + (currentItem && thumbItem.url === currentItem.url ? ' active' : '');
          const timg = document.createElement('img');
          timg.src = thumbItem.url;
          timg.onerror = () => {
            thumbItem.invalid = true;
            wrap.remove();
          };
          wrap.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            const currentScrollY = window.scrollY;
            galleryIndex = galleryItems.indexOf(thumbItem);
            renderGallery();
            window.requestAnimationFrame(() => window.scrollTo({ top: currentScrollY, left: 0 }));
          };
          wrap.appendChild(timg);
          thumbs.appendChild(wrap);
        });

        const manyPages = totalPages > 1;
        prevBtn.style.display = manyPages ? 'flex' : 'none';
        nextBtn.style.display = manyPages ? 'flex' : 'none';
        prevBtn.disabled = thumbsPage === 0;
        nextBtn.disabled = thumbsPage >= totalPages - 1;
        pages.style.display = manyPages ? 'block' : 'none';
        pages.textContent = `${thumbsPage + 1} / ${totalPages}`;
      }

      async function resolveActiveGenerationId(createdAtIso = '') {
        try {
          const res = await fetch('/api/history', { credentials: 'include' });
          if (!res.ok) return 0;
          const data = await res.json();
          const history = Array.isArray(data.history) ? data.history : [];
          const activeStatuses = new Set(['queued', 'running', 'pending']);
          if (createdAtIso) {
            const exact = history.find((item) => (
              String(item.created_at || '') === String(createdAtIso || '')
              && activeStatuses.has(String(item.status || '').toLowerCase())
            ));
            if (exact && Number(exact.id || 0) > 0) {
              return Number(exact.id);
            }
          }
          const active = history.find((item) => activeStatuses.has(String(item.status || '').toLowerCase()));
          return Number(active && active.id ? active.id : 0);
        } catch (err) {
          return 0;
        }
      }

      function buildGenerationForm() {
        if (!currentModel) return;
        if (!loggedIn) {
          document.getElementById('runStatus').textContent = labels.login_required;
          return null;
        }
        const promptEl = getPromptInput();
        const promptRaw = promptEl ? promptEl.value : '';
        const prompt = String(promptRaw || '').trim();
        if (!prompt) {
          document.getElementById('runStatus').textContent = labels.prompt_required;
          return null;
        }
        if (maxPromptLength > 0 && promptRaw.length > maxPromptLength) {
          document.getElementById('runStatus').textContent = fmt(labels.prompt_too_long, { max: maxPromptLength });
          return null;
        }
        if (currentModel.requires_reference_images && selectedFiles.length === 0) {
          document.getElementById('runStatus').textContent = labels.upload_required;
          return null;
        }
        if (currentModel.key === 'nano_banana_pro') {
          optionsState.reference_images = selectedFiles.length > 0 ? 'has' : 'none';
        }
        const form = new FormData();
        form.append('model_key', currentModel.key);
        form.append('prompt', prompt);
        const outputs = optionsState.outputs || 1;
        form.append('outputs', outputs);
        form.append('options', JSON.stringify(optionsState));

        for (const file of selectedFiles) {
          form.append('files', file);
        }
        return { form, prompt, outputs };
      }

      async function executeGeneration(prebuiltPayload = null) {
        if (runInProgress) return;
        const payload = prebuiltPayload || buildGenerationForm();
        if (!payload || !payload.form) return;
        const form = payload.form;
        const prompt = payload.prompt || '';
        runInProgress = true;
        setRunButtonState();
        document.getElementById('runStatus').textContent = labels.run_pending;
        try {
          const res = await fetch('/api/generate', { method: 'POST', body: form });
          const data = await res.json().catch(() => ({}));
          if (res.ok) {
            document.getElementById('runStatus').textContent = labels.request_sent;
            addPromptToHistory(prompt);
            generationCount += 1;
            updateSkipConfirmToggleUi();
            updateQuote();
            await loadMe();
            let generationId = Number(data.generation_id || 0);
            if (!(generationId > 0)) {
              generationId = await resolveActiveGenerationId(data.created_at || '');
            }
            if (generationId > 0) {
              generationWaitController.start(generationId, currentModel ? currentModel.key : '', Number(payload.outputs || 1));
            } else {
              setGenerationLiveState({
                visible: true,
                text: labels.gen_status_queued,
                eta: fmt(labels.gen_eta_format, { min: 10, max: 30 }),
                sub: labels.gen_taking_long,
                tone: 'warning',
                showSpinner: false,
                showCancel: false,
              });
            }
          } else {
            document.getElementById('runStatus').textContent = `${labels.error_prefix}: ${data.error || 'unknown'}`;
            showToast(labels.gen_failed_basic, 'error');
          }
        } finally {
          runInProgress = false;
          setRunButtonState();
        }
      }

      async function runGenerationFlow() {
        if (generationInFlight) {
          showToast(labels.gen_running_already, 'warning');
          const runStatus = document.getElementById('runStatus');
          if (runStatus) {
            runStatus.classList.remove('error');
            runStatus.textContent = labels.gen_running_already;
          }
          return;
        }
        if (runInProgress || confirmModalOpen) return;
        const payload = buildGenerationForm();
        if (!payload) return;
        if (!quoteData || !Number.isFinite(Number(quoteData.total))) {
          const quoted = await fetchQuoteOnce();
          if (!quoted) {
            document.getElementById('runStatus').textContent = labels.quote_unavailable;
            return;
          }
        }
        if (!hasEnoughCredits()) {
          document.getElementById('runStatus').textContent = labels.quote_insufficient;
          return;
        }

        const total = Number(quoteData.total || 0);
        if (!isConfirmRequiredForCurrentUser()) {
          await executeGeneration(payload);
          return;
        }
        openConfirmModal(total);
      }

      async function loadHistory() {
        const prevUrls = new Set(galleryItems.map((item) => item.url));
        const res = await fetch('/api/history');
        if (!res.ok) return;
        const data = await res.json();
        if (!data.history || data.history.length === 0) {
          galleryItems = [];
          renderGallery();
          return;
        }
        const prevItem = galleryItems[galleryIndex];
        const prevUrl = prevItem ? prevItem.url : null;
        const items = [];
        data.history.forEach((item) => {
          (item.urls || []).forEach((url) => {
            items.push({
              generation_id: item.id,
              model: item.model,
              created_at: item.created_at,
              prompt: item.prompt,
              url: url,
            });
          });
        });
        galleryItems = items;
        const newIndex = galleryItems.findIndex((item) => !prevUrls.has(item.url));
        if (newIndex >= 0) {
          galleryIndex = newIndex;
        } else if (prevUrl) {
          const idx = galleryItems.findIndex((x) => x.url === prevUrl);
          if (idx >= 0) {
            galleryIndex = idx;
          } else if (galleryIndex >= galleryItems.length) {
            galleryIndex = 0;
          }
        } else if (galleryIndex >= galleryItems.length) {
          galleryIndex = 0;
        }
        renderGallery();
      }

      async function redeemPromo() {
        const input = document.getElementById('promoInput');
        if (!input) return;
        const code = input.value.trim();
        if (!code) return;
        const form = new FormData();
        form.append('code', code);
        const res = await fetch('/api/redeem', { method: 'POST', body: form });
        if (res.ok) {
          const data = await res.json();
          setPromoStatus(`${labels.promo_added}: ${data.added || 0}`, 'success');
          input.value = '';
          await loadMe();
        } else {
          const data = await res.json();
          setPromoStatus(`${labels.promo_error}: ${data.error || 'unknown'}`, 'error');
        }
      }

      async function createCryptoInvoice() {
        if (!loggedIn) {
          setCryptoStatus(labels.login_required, 'error');
          return;
        }
        const select = document.getElementById('cryptoPackage');
        if (!select) return;
        const productId = Number(select.value || 0);
        if (!productId) {
          setCryptoStatus(labels.crypto_packages_empty, 'error');
          return;
        }

        const createBtn = document.getElementById('cryptoCreateBtn');
        const payLink = document.getElementById('cryptoPayLink');
        const checkBtn = document.getElementById('cryptoCheckBtn');
        if (!createBtn || !payLink || !checkBtn) return;
        createBtn.disabled = true;
        setCryptoStatus(labels.crypto_loading_packages);

        let response;
        try {
          response = await fetch('/api/payments/cryptopay/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ product_id: productId }),
          });
        } catch (err) {
          createBtn.disabled = false;
          setCryptoStatus(labels.crypto_create_failed, 'error');
          return;
        }
        createBtn.disabled = false;

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          if (errorData.error === 'cryptopay_not_configured') {
            setCryptoStatus(labels.crypto_unavailable, 'error');
            return;
          }
          setCryptoStatus(labels.crypto_create_failed, 'error');
          return;
        }

        const data = await response.json();
        cryptoInvoiceUuid = data.invoice_id || '';
        cryptoInvoiceCredits = Number(data.credits_amount || 0);
        payLink.href = data.pay_url || '#';
        payLink.style.display = data.pay_url ? 'inline-flex' : 'none';
        checkBtn.disabled = !cryptoInvoiceUuid;

        const amount = formatMoney(data.amount);
        const currency = data.currency || '';
        setCryptoStatus(fmt(labels.crypto_invoice_created, { amount, currency }));

        if (data.pay_url) {
          openExternalLink(data.pay_url);
        }
        stopCryptoPolling();
        cryptoPollTimer = setInterval(() => {
          void checkCryptoStatus(false);
        }, 5000);
      }

      async function checkCryptoStatus(showWaiting = true) {
        if (!cryptoInvoiceUuid) {
          if (showWaiting) {
            setCryptoStatus(labels.crypto_status_failed, 'error');
          }
          return;
        }
        if (cryptoPollBusy) return;
        cryptoPollBusy = true;

        try {
          const res = await fetch(`/api/payments/cryptopay/status/${encodeURIComponent(cryptoInvoiceUuid)}`, {
            credentials: 'include',
          });
          if (!res.ok) {
            if (showWaiting) {
              setCryptoStatus(labels.crypto_status_failed, 'error');
            }
            return;
          }
          const data = await res.json();
          const status = (data.invoice_status || '').toLowerCase();
          if (data.paid || status === 'paid' || status === 'overpaid') {
            const creditsAdded = Number(data.credits_added || cryptoInvoiceCredits || 0);
            setCryptoStatus(fmt(labels.crypto_paid, { credits: creditsAdded }), 'success');
            await loadMe();
            stopCryptoPolling();
            return;
          }
          if (status === 'partial') {
            setCryptoStatus(labels.crypto_partial_payment);
          } else if (status === 'canceled' || status === 'cancelled' || status === 'expired') {
            setCryptoStatus(labels.crypto_canceled, 'error');
            stopCryptoPolling();
          } else if (showWaiting || status === 'created') {
            setCryptoStatus(labels.crypto_waiting_payment);
          }
        } catch (err) {
          if (showWaiting) {
            setCryptoStatus(labels.crypto_status_failed, 'error');
          }
        } finally {
          cryptoPollBusy = false;
          cryptoPollAttempts += 1;
          if (cryptoPollAttempts >= 120) {
            stopCryptoPolling();
          }
        }
      }

      const topupMenu = document.getElementById('topupMenu');
      const topupButton = document.getElementById('topupButton');
      const topupDropdown = document.getElementById('topupDropdown');
      const topupRedeemOption = document.getElementById('topupRedeemOption');
      const topupStarsOption = document.getElementById('topupStarsOption');
      const topupCryptoOption = document.getElementById('topupCryptoOption');
      const topupModal = document.getElementById('topupModal');
      const topupModalClose = document.getElementById('topupModalClose');
      const topupModalTitle = document.getElementById('topupModalTitle');
      const topupSectionRedeem = document.getElementById('topupSectionRedeem');
      const topupSectionCrypto = document.getElementById('topupSectionCrypto');

      function closeTopupDropdown() {
        if (!topupDropdown) return;
        topupDropdown.classList.remove('open');
        if (topupButton) {
          topupButton.setAttribute('aria-expanded', 'false');
        }
      }

      function openTopupModal(mode) {
        if (!topupModal || !topupModalTitle || !topupSectionRedeem || !topupSectionCrypto) return;
        closeTopupDropdown();
        topupModal.classList.add('open');
        topupModal.setAttribute('aria-hidden', 'false');
        topupSectionRedeem.classList.remove('active');
        topupSectionCrypto.classList.remove('active');
        if (mode === 'redeem') {
          topupModalTitle.textContent = labels.topup_modal_redeem_title;
          topupSectionRedeem.classList.add('active');
          setPromoStatus('');
          const input = document.getElementById('promoInput');
          if (input) {
            setTimeout(() => input.focus(), 60);
          }
          return;
        }
        topupModalTitle.textContent = labels.topup_modal_crypto_title;
        topupSectionCrypto.classList.add('active');
        setCryptoStatus('');
        void loadCryptoPackages();
      }

      function closeTopupModal() {
        if (!topupModal) return;
        topupModal.classList.remove('open');
        topupModal.setAttribute('aria-hidden', 'true');
      }

      function openTelegramStarsTopup() {
        closeTopupDropdown();
        if (!botUsername) {
          openTopupModal('redeem');
          setPromoStatus(labels.topup_stars_unavailable, 'error');
          return;
        }
        const deepLink = `https://t.me/${botUsername}?start=buy`;
        const runStatus = document.getElementById('runStatus');
        if (runStatus) {
          runStatus.textContent = labels.topup_stars_redirect;
        }
        openTelegramDeepLink(deepLink);
      }

      const promptInputEl = getPromptInput();
      const promptHelperBtn = document.getElementById('promptHelperBtn');
      const promptHistoryBtn = document.getElementById('promptHistoryBtn');
      const promptHelperPanel = document.getElementById('promptHelperPanel');
      const promptHistoryPanel = document.getElementById('promptHistoryPanel');
      const promptHelperList = document.getElementById('promptHelperList');
      const promptHistoryList = document.getElementById('promptHistoryList');

      promptHistory = loadPromptHistory();
      favorites = loadFavorites();
      renderPromptHelper();
      renderPromptHistory();
      updatePromptLengthHint();
      wirePromptListKeyboard(promptHelperList);
      wirePromptListKeyboard(promptHistoryList);

      if (promptInputEl) {
        promptInputEl.addEventListener('input', updatePromptLengthHint);
      }
      if (promptHelperBtn) {
        promptHelperBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          openPromptPanel('promptHelperPanel', 'promptHelperBtn');
        });
      }
      if (promptHistoryBtn) {
        promptHistoryBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          renderPromptHistory();
          openPromptPanel('promptHistoryPanel', 'promptHistoryBtn');
        });
      }
      if (promptHelperPanel) {
        promptHelperPanel.addEventListener('click', (event) => event.stopPropagation());
      }
      if (promptHistoryPanel) {
        promptHistoryPanel.addEventListener('click', (event) => event.stopPropagation());
      }
      if (promptHelperList) {
        promptHelperList.addEventListener('click', (event) => {
          const target = event.target instanceof Element ? event.target.closest('[data-template-id]') : null;
          if (!target) return;
          const templateId = target.getAttribute('data-template-id') || '';
          const template = PROMPT_TEMPLATES.find((item) => item.id === templateId);
          if (!template) return;
          insertIntoPrompt(template.text);
          closePromptPanels();
          trackUiEvent('prompt_template_selected', { template_id: template.id });
        });
      }
      if (promptHistoryList) {
        promptHistoryList.addEventListener('click', (event) => {
          const node = event.target instanceof Element ? event.target : null;
          if (!node) return;
          const removeBtn = node.closest('[data-history-remove]');
          if (removeBtn) {
            const index = Number(removeBtn.getAttribute('data-history-remove'));
            removePromptFromHistory(index);
            return;
          }
          const promptBtn = node.closest('[data-history-index]');
          if (!promptBtn) return;
          const index = Number(promptBtn.getAttribute('data-history-index'));
          const value = promptHistory[index] || '';
          if (!value) return;
          insertIntoPrompt(value);
          closePromptPanels();
          trackUiEvent('prompt_history_reused', { history_index: index });
        });
      }
      const viewCarouselBtn = document.getElementById('viewCarouselBtn');
      const viewGridBtn = document.getElementById('viewGridBtn');
      if (viewCarouselBtn) {
        viewCarouselBtn.addEventListener('click', () => setGalleryMode('carousel'));
      }
      if (viewGridBtn) {
        viewGridBtn.addEventListener('click', () => setGalleryMode('grid'));
      }
      const editModelModal = document.getElementById('editModelModal');
      const editModelList = document.getElementById('editModelList');
      if (editModelList) {
        editModelList.addEventListener('click', (event) => {
          const node = event.target instanceof Element ? event.target.closest('[data-edit-model]') : null;
          if (!node) return;
          const modelKey = node.getAttribute('data-edit-model') || '';
          if (!modelKey) return;
          void applyEditWithAiModel(modelKey);
        });
      }
      if (editModelModal) {
        editModelModal.addEventListener('click', (event) => {
          if (event.target === editModelModal) {
            closeEditWithAiModal();
          }
        });
      }
      const genCancelBtn = document.getElementById('genCancelBtn');
      if (genCancelBtn) {
        genCancelBtn.addEventListener('click', () => {
          generationWaitController.cancelLocally();
        });
      }

      document.getElementById('runBtn').onclick = runGenerationFlow;
      const promoBtn = document.getElementById('promoBtn');
      if (promoBtn) {
        promoBtn.onclick = redeemPromo;
      }
      const quoteInfoBtn = document.getElementById('quoteInfoBtn');
      const quoteLineEl = document.getElementById('quoteLine');
      if (quoteInfoBtn) {
        quoteInfoBtn.addEventListener('click', (event) => {
          event.preventDefault();
          event.stopPropagation();
          toggleQuoteTooltip();
        });
        quoteInfoBtn.addEventListener('mouseenter', openQuoteTooltip);
        quoteInfoBtn.addEventListener('focus', openQuoteTooltip);
        quoteInfoBtn.addEventListener('blur', () => {
          setTimeout(() => {
            const quoteLineEl = document.getElementById('quoteLine');
            if (!quoteLineEl || !quoteLineEl.contains(document.activeElement)) {
              closeQuoteTooltip();
            }
          }, 0);
        });
      }
      if (quoteLineEl) {
        quoteLineEl.addEventListener('mouseleave', closeQuoteTooltip);
      }
      const skipConfirmToggleEl = document.getElementById('skipConfirmToggle');
      if (skipConfirmToggleEl) {
        skipConfirmToggleEl.addEventListener('change', () => {
          if (isNewUserMandatoryConfirm()) {
            skipConfirmToggleEl.checked = false;
            setSkipConfirmSetting(false);
            return;
          }
          setSkipConfirmSetting(!!skipConfirmToggleEl.checked);
        });
      }
      const confirmCancelBtn = document.getElementById('confirmCancelBtn');
      if (confirmCancelBtn) {
        confirmCancelBtn.addEventListener('click', closeConfirmModal);
      }
      const confirmOkBtn = document.getElementById('confirmOkBtn');
      if (confirmOkBtn) {
        confirmOkBtn.addEventListener('click', async () => {
          const dontShowCheckbox = document.getElementById('confirmDontShowCheckbox');
          if (dontShowCheckbox && !dontShowCheckbox.disabled) {
            setSkipConfirmSetting(!!dontShowCheckbox.checked);
            updateSkipConfirmToggleUi();
          }
          closeConfirmModal();
          await executeGeneration();
        });
      }
      const confirmModalEl = document.getElementById('confirmModal');
      if (confirmModalEl) {
        confirmModalEl.addEventListener('click', (event) => {
          if (event.target === confirmModalEl) {
            closeConfirmModal();
          }
        });
      }
      const cryptoCreateBtn = document.getElementById('cryptoCreateBtn');
      if (cryptoCreateBtn) {
        cryptoCreateBtn.onclick = createCryptoInvoice;
      }
      const cryptoSelectEl = document.getElementById('cryptoPackage');
      if (cryptoSelectEl) {
        cryptoSelectEl.addEventListener('change', () => {
          renderCryptoPackageCards();
        });
      }
      const cryptoCheckBtn = document.getElementById('cryptoCheckBtn');
      if (cryptoCheckBtn) {
        cryptoCheckBtn.onclick = () => checkCryptoStatus(true);
      }
      const cryptoPayLinkEl = document.getElementById('cryptoPayLink');
      if (cryptoPayLinkEl) {
        cryptoPayLinkEl.addEventListener('click', (event) => {
          const href = cryptoPayLinkEl.getAttribute('href') || '';
          if (!href || href === '#') return;
          if (!isMiniApp) return;
          event.preventDefault();
          openExternalLink(href);
        });
      }
      document.getElementById('thumbsPrev').onclick = (e) => {
        e.preventDefault();
        if (thumbsPage <= 0) return;
        const currentScrollY = window.scrollY;
        thumbsPage -= 1;
        renderThumbs(galleryItems[galleryIndex] || null, false);
        window.requestAnimationFrame(() => window.scrollTo({ top: currentScrollY, left: 0 }));
      };
      document.getElementById('thumbsNext').onclick = (e) => {
        e.preventDefault();
        const currentScrollY = window.scrollY;
        thumbsPage += 1;
        renderThumbs(galleryItems[galleryIndex] || null, false);
        window.requestAnimationFrame(() => window.scrollTo({ top: currentScrollY, left: 0 }));
      };
      const promoInputEl = document.getElementById('promoInput');
      if (promoInputEl) {
        promoInputEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            redeemPromo();
          }
        });
      }
      if (topupButton && topupDropdown) {
        topupButton.addEventListener('click', (event) => {
          event.stopPropagation();
          const open = !topupDropdown.classList.contains('open');
          closeTopDropdowns();
          closePromptPanels();
          if (open) {
            topupDropdown.classList.add('open');
            topupButton.setAttribute('aria-expanded', 'true');
          }
        });
      }
      if (topupRedeemOption) {
        topupRedeemOption.addEventListener('click', () => openTopupModal('redeem'));
      }
      if (topupStarsOption) {
        topupStarsOption.addEventListener('click', openTelegramStarsTopup);
      }
      if (topupCryptoOption) {
        topupCryptoOption.addEventListener('click', () => openTopupModal('crypto'));
      }
      if (topupModalClose) {
        topupModalClose.addEventListener('click', closeTopupModal);
      }
      if (topupModal) {
        topupModal.addEventListener('click', (event) => {
          if (event.target === topupModal) {
            closeTopupModal();
          }
        });
      }
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (generationWaitController.isActive()) {
            generationWaitController.cancelLocally();
          }
          closeEditWithAiModal();
          closeConfirmModal();
          closeQuoteTooltip();
          closePromptPanels();
          closeTopupModal();
          closeTopDropdowns();
        }
      });
      window.addEventListener('resize', () => {
        if (!galleryItems.length || galleryMode !== 'carousel' || resultSkeletonActive) return;
        renderThumbs(galleryItems[galleryIndex] || null, false);
      });
      window.addEventListener('beforeunload', () => {
        stopCryptoPolling();
        generationWaitController.stopAndHide();
      });
      const refInput = document.getElementById('refFiles');
      const refReplaceInput = document.getElementById('refReplaceFile');
      const refGrid = document.getElementById('refGrid');
      const uploadBlockEl = document.getElementById('uploadBlock');
      let replaceRefIndex = -1;
      let refDragDepth = 0;

      function modelSupportsRefImages() {
        return !!(
          currentModel &&
          (currentModel.supports_reference_images || currentModel.requires_reference_images)
        );
      }

      function setRefDropActive(active) {
        if (!uploadBlockEl) return;
        uploadBlockEl.classList.toggle('ref-drop-active', !!active);
      }

      function clearRefDropActive() {
        refDragDepth = 0;
        setRefDropActive(false);
      }

      function collectImageFilesFromDataTransfer(dataTransfer) {
        const files = [];
        if (!dataTransfer) return files;

        const items = Array.from(dataTransfer.items || []);
        for (const item of items) {
          if (!item || item.kind !== 'file') continue;
          const mime = String(item.type || '').toLowerCase();
          if (!mime.startsWith('image/')) continue;
          const file = item.getAsFile ? item.getAsFile() : null;
          if (file) files.push(file);
        }

        if (!files.length) {
          const fallback = Array.from(dataTransfer.files || []);
          for (const file of fallback) {
            const mime = String(file.type || '').toLowerCase();
            if (mime.startsWith('image/')) files.push(file);
          }
        }
        return files;
      }

      function collectImageFilesFromClipboard(clipboardData) {
        if (!clipboardData) return [];
        return collectImageFilesFromDataTransfer(clipboardData);
      }

      function addReferenceFiles(files) {
        if (!modelSupportsRefImages()) return 0;
        const incoming = Array.from(files || []);
        if (!incoming.length) return 0;
        const max = currentModel.max_reference_images || 0;
        let added = 0;

        for (const file of incoming) {
          if (!(file instanceof File)) continue;
          const mime = String(file.type || '').toLowerCase();
          if (!mime.startsWith('image/')) continue;
          if (selectedFiles.length >= max) break;
          selectedFiles.push(file);
          refPreviews.push(URL.createObjectURL(file));
          added += 1;
        }

        if (added > 0) {
          syncRefInput();
          renderRefGrid();
        }
        return added;
      }

      function syncRefInput() {
        const dt = new DataTransfer();
        selectedFiles.forEach((file) => dt.items.add(file));
        refInput.files = dt.files;
      }

      function resetRefSelection() {
        refPreviews.forEach((url) => URL.revokeObjectURL(url));
        refPreviews = [];
        selectedFiles = [];
        syncRefInput();
        renderRefGrid();
      }

      function renderRefGrid() {
        refGrid.innerHTML = '';
        if (!currentModel) return;
        const max = currentModel.max_reference_images || 0;
        selectedFiles.forEach((file, idx) => {
          const tile = document.createElement('div');
          tile.className = 'ref-thumb';
          const img = document.createElement('img');
          img.src = refPreviews[idx];
          tile.appendChild(img);
          const remove = document.createElement('button');
          remove.type = 'button';
          remove.className = 'ref-remove';
          remove.textContent = '×';
          remove.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            URL.revokeObjectURL(refPreviews[idx]);
            refPreviews.splice(idx, 1);
            selectedFiles.splice(idx, 1);
            syncRefInput();
            renderRefGrid();
          };
          tile.appendChild(remove);

          const replace = document.createElement('button');
          replace.type = 'button';
          replace.className = 'ref-replace';
          replace.textContent = labels.ref_replace;
          replace.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            replaceRefIndex = idx;
            refReplaceInput.value = '';
            refReplaceInput.click();
          };
          tile.appendChild(replace);
          refGrid.appendChild(tile);
        });

        if (selectedFiles.length < max) {
          const add = document.createElement('div');
          add.className = 'ref-tile';
          add.innerHTML = `<div class="ref-add-icon">⬆️</div><strong>${labels.ref_add}</strong><div>${labels.ref_add_sub}</div>`;
          add.onclick = () => refInput.click();
          refGrid.appendChild(add);
        }
        updateRefHint();
        updateQuote();
      }

      refInput.addEventListener('change', () => {
        addReferenceFiles(Array.from(refInput.files || []));
        refInput.value = '';
      });

      refReplaceInput.addEventListener('change', () => {
        if (!currentModel) return;
        const file = Array.from(refReplaceInput.files || [])[0];
        const idx = replaceRefIndex;
        replaceRefIndex = -1;
        if (!file || idx < 0 || idx >= selectedFiles.length) return;
        if (refPreviews[idx]) {
          URL.revokeObjectURL(refPreviews[idx]);
        }
        selectedFiles[idx] = file;
        refPreviews[idx] = URL.createObjectURL(file);
        syncRefInput();
        renderRefGrid();
      });

      if (uploadBlockEl) {
        uploadBlockEl.addEventListener('dragenter', (event) => {
          if (!modelSupportsRefImages()) return;
          const hasFiles = Array.from(event.dataTransfer?.types || []).includes('Files');
          if (!hasFiles) return;
          event.preventDefault();
          refDragDepth += 1;
          setRefDropActive(true);
        });

        uploadBlockEl.addEventListener('dragover', (event) => {
          if (!modelSupportsRefImages()) return;
          const hasFiles = Array.from(event.dataTransfer?.types || []).includes('Files');
          if (!hasFiles) return;
          event.preventDefault();
          if (event.dataTransfer) {
            event.dataTransfer.dropEffect = 'copy';
          }
          setRefDropActive(true);
        });

        uploadBlockEl.addEventListener('dragleave', (event) => {
          if (!modelSupportsRefImages()) return;
          event.preventDefault();
          refDragDepth = Math.max(0, refDragDepth - 1);
          if (refDragDepth === 0) {
            setRefDropActive(false);
          }
        });

        uploadBlockEl.addEventListener('drop', (event) => {
          if (!modelSupportsRefImages()) return;
          event.preventDefault();
          const files = collectImageFilesFromDataTransfer(event.dataTransfer);
          addReferenceFiles(files);
          clearRefDropActive();
        });
      }

      document.addEventListener('paste', (event) => {
        if (!modelSupportsRefImages()) return;
        const files = collectImageFilesFromClipboard(event.clipboardData);
        if (!files.length) return;
        event.preventDefault();
        addReferenceFiles(files);
      });

      setRunButtonState();
      updateSkipConfirmToggleUi();
      renderQuote();

      let quoteTimer = null;

      async function maybeAutoMiniAppAuth() {
        if (loggedIn) return false;
        if (!isMiniApp || !tgWebApp) return false;
        if (loginWidget) {
          loginWidget.style.display = 'none';
        }
        setMiniAppAuthNotice(labels.miniapp_auth_in_progress || '');
        try {
          tgWebApp.ready();
          tgWebApp.expand();
        } catch (e) {
          // no-op
        }
        const initData = (tgWebApp.initData || '').trim();
        if (!initData) return false;
        try {
          const res = await fetch('/auth/miniapp', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ init_data: initData }),
          });
          if (res.ok) {
            window.location.reload();
            return true;
          }
          const err = await res.json().catch(() => ({}));
          console.warn('miniapp auth rejected', err);
          setMiniAppAuthNotice(labels.miniapp_auth_failed || '', 'error');
        } catch (err) {
          console.warn('miniapp auth failed', err);
          setMiniAppAuthNotice(labels.miniapp_auth_failed || '', 'error');
        }
        return false;
      }

      (async () => {
        const reloading = await maybeAutoMiniAppAuth();
        if (reloading) return;
        loadModels();
        if (loggedIn) {
          loadMe();
          loadHistory();
          setInterval(loadHistory, 15000);
          return;
        }
        if (!isMiniApp) {
          setMiniAppAuthNotice('');
        }
      })();

      function buildQuotePayload() {
        if (!currentModel) return null;
        const payload = {
          model_key: currentModel.key,
          outputs: optionsState.outputs || 1,
          options: { ...optionsState },
        };
        if (currentModel.key === 'nano_banana_pro') {
          payload.options.reference_images = selectedFiles.length > 0 ? 'has' : 'none';
        }
        return payload;
      }

      async function fetchQuoteOnce() {
        const payload = buildQuotePayload();
        if (!payload) {
          quoteData = null;
          renderQuote();
          return false;
        }
        try {
          const res = await fetch('/api/quote', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!res.ok) {
            quoteData = null;
            renderQuote();
            return false;
          }
          const data = await res.json();
          quoteData = data;
          renderQuote();
          return true;
        } catch (err) {
          quoteData = null;
          renderQuote();
          return false;
        }
      }

      async function updateQuote() {
        if (!currentModel) {
          quoteData = null;
          renderQuote();
          return;
        }
        if (!loggedIn) {
          quoteData = null;
          renderQuote();
          return;
        }
        if (quoteTimer) {
          clearTimeout(quoteTimer);
        }
        quoteTimer = setTimeout(async () => {
          await fetchQuoteOnce();
        }, 200);
      }

      async function onTelegramAuth(user) {
        const res = await fetch('/auth/telegram', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(user),
        });
        if (res.ok) {
          window.location.reload();
        } else {
          alert(labels.error_prefix + ': auth_failed');
        }
      }

      const userButton = document.getElementById('userButton');
      const userDropdown = document.getElementById('userDropdown');
      const langButton = document.getElementById('langButton');
      const langDropdown = document.getElementById('langDropdown');

      function closeTopDropdowns() {
        if (userDropdown) {
          userDropdown.classList.remove('open');
        }
        if (userButton) {
          userButton.setAttribute('aria-expanded', 'false');
        }
        if (langDropdown) {
          langDropdown.classList.remove('open');
        }
        if (langButton) {
          langButton.setAttribute('aria-expanded', 'false');
        }
        if (topupDropdown) {
          topupDropdown.classList.remove('open');
        }
        if (topupButton) {
          topupButton.setAttribute('aria-expanded', 'false');
        }
      }

      if (userButton && userDropdown) {
        userButton.addEventListener('click', (event) => {
          event.stopPropagation();
          const open = !userDropdown.classList.contains('open');
          closeTopDropdowns();
          closePromptPanels();
          if (open) {
            userDropdown.classList.add('open');
            userButton.setAttribute('aria-expanded', 'true');
          }
        });
      }
      if (langButton && langDropdown) {
        langButton.addEventListener('click', (event) => {
          event.stopPropagation();
          const open = !langDropdown.classList.contains('open');
          closeTopDropdowns();
          closePromptPanels();
          if (open) {
            langDropdown.classList.add('open');
            langButton.setAttribute('aria-expanded', 'true');
          }
        });
      }
      document.addEventListener('click', (event) => {
        closeTopDropdowns();
        if (!isPromptUiTarget(event.target)) {
          closePromptPanels();
        }
        const quoteLineEl = document.getElementById('quoteLine');
        if (quoteTooltipOpen && quoteLineEl && !quoteLineEl.contains(event.target)) {
          closeQuoteTooltip();
        }
      });
    </script>
  </body>
</html>
